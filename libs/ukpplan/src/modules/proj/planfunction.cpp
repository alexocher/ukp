#include <defMacro>
#include <TModuleEmployees>
#include <TModulePlans>
#include <QMessageBox>
#include <QtCore>
#include <QProgressDialog>

// Терминология:
// Номер рабочего часа года м.б. от 0 до 365*8. В году 365 суток по 8 часов. Считаем, что в сутках только 8 часов (только рабочие часы).
// Номер дня года м.б. от 0 до 365.
// Минимальная единица измерения времени - 1 час.
// Астрономическое время в формате QDateTime. Минуты и секунды нигде не используются.
// Номер рабочего часа суток м.б. от 0 до 7. Количество рабочих часов в сутках kolhours (по-умолчанию = 8 часов).
// Начало рабочего дня beginworkday (по - умолчанию = 9 часов)
// Рабочий день (по - умолчанию с 9:00 до 17:00). 8 рабочих часов начинаются в: 9, 10, 11, 12, 13, 14, 15, 16 часов.
// Минимально разрешенное время начала продукции (beginmin) - время, раньше которого выполнение продукции не начнется. Позже - может.
// Максимально разрешенное время конца продукции (endmax) - время, до которого продукции должна быть выполнена. Если это требование невыполнимо -
//планирование отменяется с сообщением об ошибке.
// В объекте tasks (в формате QDateTime) времена начала и конца всегда хранятся, как НАЧАЛО астрономического часа. Минуты и секунды не участвуют.
// Прямое планирование (обычное), когда работы планируются слева - направо (найти начало, а затем конец). М.б. задано минимально разрешенное
//время начала продукции. Используется всегда, когда НЕ ЗАДАНО максимальное время конца продукции.
// Обратное планирование, когда работы планируются справа - налево. Сначала находится конец работы, а затем начало работы. Используется только
//тогда, когда ЗАДАНО максимальное время конца продукции.
// Планирование проводится в условных единицах времени. Поэтому, при длительности работы 1 единица, время начала работы м.б. равно времени конца.
// Планировать можно только начиная с текущего рабочего часа. Планирование ранее, чем текущий рабочий час (планирование "в прошлом") - недопустимо.
// Календарь предприятия - не используется. Используются только календари исполнителей, которые содержат в себе нерабочие дни исполнителя: отпуск,
//командировка, болезнь, а также праздничные дни и выходные. Т.е. календарь исполнителя содержит в себе и календарь предприятия.
// Особенность основного алгоритма планирования заключается в последовательном планировании продукции, начиная с продукции с наивысшим приоритетом.
//Внутри каждой процедуры все работы выполняются только последовательно.
//Недостаток такого алгоритма - точное решение не находится, только приближенное. Достоинство - быстрота (нет полного перебора вариантов).
// Принцип "последовательности" выполнения работ означает, что работа не может начаться раньше, чем закончится предыдущая (в рамках одной процедуры).
//Каждая текущая процедура может опираться на другие процедуры (в рамках только одной продукции).
// Принцип "дублирования" работ означент, что один исполнитель не может одновременно выполнять более одной работы.
// Приоритет продукции (по-умолчанию = 0) позволяет управлять последовательностью планирования продукции. Чем выше приоритет, тем быстрее будет
//выполняться продукция. Приоритеты м.б. одинаковыми у нескольких продукций, в этом случае последовательность планирования продукций будет
//определяться случайным образом (так, как они расположены в объекте tasks). Что бы ускорить выполнение продукции (за счет остальных) достаточно
//увеличить приоритет продукции. Продукции с самым высоким приоритетом будут выделены все ресурсы для выполнения в максимально сжатые сроки.
// Приоритет работы соответствует приоритету проекта (продукции), которому принадлежит работа.
// Защищенная работа не может быть изменена в процессе планирования. Использование защищенных работ требует навыка и
//понимания процесса планирования. Например, увеличение длительности незащищенной работы в окружении защищенных работ может вызвать ошибку
//нарушения принципа последовательности.
// В каждой процедуре есть начальная работа и последняя. Остальные работы называются внутренними работами процедуры.
// Каждая процедура должна содержать хотя бы одну работу. Пустые процедуры не допускаются. Пустые планы, продукции и проекты - допускаются.
// Каждая i-ая процедура может опираться на одну или несколько других (опорных) процедур, т.е. i-ая процедура может начаться только после завершения
//опорных процедур. Опорных процедур может не быть, тогда i-ая процедура может начаться в любое время. Каждая процедура может опираться на процедуры
//только с меньшим порядковым номером (индексом). Для выполнения этого требования может потребоваться ручное выполнение упорядочиваня процедур в шаблоне.
//Опорные процедуры - это те на которые опиравется текущая процедура. Опирающиеся процедуры - это те, которые опираются на текущую процедуру.
// Все работы одной процедуры может выполняет только один исполнитель. Возможных исполнителей м.б. несколько. Для внешних работ допускается пустой
//список возможных исполнителей и проверка на дублирование не производится.

// АЛГОРИТМ обработки beginmin и endmax (заданы или не заданы):
// - beginmin - нет, endmax - нет. Прямое планирование начинается с текущего рабочего часа. beginmin и endmax - не учитываются.
// - beginmin - да,  endmax - нет. Прямое планирование начинается с beginmin. endmax и текущий рабочий час - не учитываются.
// - beginmin - нет, endmax - да.  Обратное планирование заканчивается в endmax. Если найденное начало планирования меньше текущего рабочего часа, то
//                                 прервать планирование и сообщить об этом. beginmin - не учитывается.
// - beginmin - да,  endmax - да.  Обратное планирование начнется с endmax. Если найденное начало планирования будет меньше beginmin, то прервать планирование
//                                 и сообщить об этом. Текущий рабочий час - не учитывается. При этом вся продукция "притягиваются" к заданному концу, а не
//                                 к заданному началу. Если продукция "не помещается" в заданный интервал, то планирование прерывается с сообщением об ошибке.

// объявить глобальные переменные (задать неименованное пространство имен. Скрыть видимость переменных из вне)
namespace {

    int   tbeginplan      = 0;       // номер текущего рабочего часа года (от 0 до 356*8), с которого начнется планирование (аналог текущей даты)
    int   numerror        = 0;       // порядковый номер ошибки для вывода сообщения об ошибках
    int   kolworkhoursday = 8;       // количество рабочих часов в сутках
    int   beginworkday    = 9;       // начало рабочего дня 9:00. Первый рабочий час будет начинаться в 9:00. Последний, 8-ой
                                     //рабочий час будет начинаться в (beginworkday + kolhours - 1) в 16:00
    QDate beginyearplan;             // начало года планирования (начало года самого раннего из всех планов в базе)
    QString begin         = "begin"; // константы для удобства вызова универсальных функций
    QString end           = "end";   // константы для удобства вызова универсальных функций
    int   flprint         = 0;       // флаг печати (вывода) отладочной информации в консоль: 0-ничего; 1-ошибки,план; 2-ошибки,план,job;
                                     //3-ошибки,план,job,tasks
    QDateTime emptydate(QDate(2000,1,1), QTime(9,0)); // именно такая дата появляется, если очистить поле "Планировать с ..." и "Завершить до ...". Такая
                                     //дата считается "пустой" (не заполненной) и не будет учитываться при планировании
    QProgressDialog* pprd;           // индикатор прогресса ProgressDialog
    int step;                        // счетчик спланированных процедур для отображения ProgressDialog
    int kolproc;                     // общее количество процедур в векторе job для ProgressDialog

    struct executor_type { // структура исполнителя
        int  id;           // id исполнителя
        bool external;     // исполнитель внешний (true) или внутренний (false)
        QVector<int>rest;  // вектор нерабочих ЧАСОВ года исполнителя (отпуск, командировка, праздничные и вых. дни). Начиная с 0
    };

    struct job_type { // структура работы
        int                    id;               // id работы
        bool                   changes;          // true - признак того, что продукция была изменена. Хранится во всех работах продукции. Используется
                                                 //для того, что бы определить: надо ли сохранять план. Если были изменения, то план надо сохранить
        int                    priority;         // приоритет проекта, которому принадлежит работа. 0 - низший приоритет (по - умолчанию). М.б. одинаковым
                                                 //у разных продкций

        int                    projectnum;       // номер (num) проекта, которому принадлежит работа (только для формирования сообщения об ошибке)
        QString                projectname;      // наименование проекта, которому принадлежит работа (только для формирования сообщения об ошибке)

        int                    productnum;       // номер продукции, которой принадлежит работа (только для формирования сообщения об ошибке)
        QString                productname;      // наименование продукции, которой принадлежит работа (только для формирования сообщения об ошибке)

        int                    procedurenum;     // номер процедуры, которой принадлежит работа (для сообщения об ошибке и для перехода к индексам процедур)
        QString                procedurename;    // наименование процедуры, которой принадлежит работа (только для формирования сообщения об ошибке)
        QVector<int>           prevprocedurenum; // список номеров (num) опорных (предыдущих) процедур.
        QVector<int>           prevprocedureind; // список индексов (j в векторе job, нач. c 0) опорных процедур

        int                    num;              // номер работы (только для формирования сообщения об ошибке)
        QString                name;             // наименование работы (только для формирования сообщения об ошибке)

        int                    beginmin;         // заданное мин. разрешенное время (рабочий час года) начала работы (из "Планировать проект с...")
                                                 //(от 0 до 365*8). По умолчанию = 0
        int                    begin;            // найденное время (рабочий час года) начала выполнения работы (от 0 до 365*8)
        int                    time;             // полное время выполнения работы в часах
        int                    end;              // найденное время (рабочий час года) окончания работы (от 0 до 365*8)
        int                    endmax;           // заданное максимально разрешенное время (рабочий час года) конца работы (из "Закончить до...")
                                                 //(от 0 до 365*8). Если задан 0 (по - умолчанию), то считать, что ограничения по концу - нет
        executor_type          executor;         // назначенный исполнитель работы (обязательно из списка возможных исполнителей people)
        QVector<executor_type> people;           // список возможных исполнителей работы (с пустым списком планирование невозможно). Пустой список
                                                 //допускается только для защищенных уже спланировыанных ранее работ
        bool                   protection;       // признак защиты работы от редактирования (true - защищена; false - можно редактировать). Данные защищенной
                                                 //работы не меняются в процессе планирования, но эти данные используются для планирования других работ
    };

    QVector<QVector<QVector<job_type>>> job;     // вектор работ, содержащий всю информацию по всем работам
    QVector<executor_type> executor;             // вектор исполнителей (общий список из people всех работ). Т.е. все исполнители из job
}

// объявить прототипы функций
QDateTime NumWorkHourYearToDateTime(int &n, QString &str);
int       DateTimeToNumWorkHourYear(QDateTime &dt, QString &str);
int       TestTCarryTaskBeforePlanning(TCarryTaskList &tasks, QString &errs);
int       TestTCarryTaskAfterPlanning(TCarryTaskList &tasks, QString &errs);
int       TestJobBeforePlanning(QString &errs);
int       TestPlan(QString &errs);
void      FindBeginEndJob(executor_type &executor, int &tstart, int &time, int &tbegin, int &tend);
void      FindEndBeginJob(executor_type &executor, int &tstart, int &time, int &tbegin, int &tend);
job_type  FindJob(int &code);
void      SortingVectorJob();
void      FillVectorJob(TCarryTaskList &tasks);
void      FillVectorJobIndPrevProcedure();
int       ProcedureNumToInd(int &i, int &num);
void      CorrectionProcedure();
void      PrinTCarryTask(TCarryTaskList &tasks);
void      PrintPlan();
void      PrintJob();
void      WritePlan(TCarryTaskList &tasks);
bool      TestJobOrderBeginEnd(int &l, int &m, int &n, int &ttek);
bool      TestJobOrderEndBegin(int &l, int &m, int &n, int &ttek);
int       PlanJobBeginEnd(int &l, int &m, int &n, QString &errs);
int       PlanJobEndBegin(int &l, int &m, int &n, QString &errs);
int       PlanProductBeginEnd(int &l, QString &errs);
int       PlanProductEndBegin(int &l, QString &errs);
int       Plan(TCarryTaskList &tasks, QString &errs);

QDateTime NumWorkHourYearToDateTime(int &n, QString &str) // перейти от номера рабочего часа года к QDateTime
{
    // По номеру рабочего часа (n) года (от 0 до 365*8) найти астрономическое время начала в формате QDateTime.
    // Если str == "begin", то найти астрономическое время начала рабочего часа,
    //если str == "end", то найти астрономическое время НЕ конца часа, а начало СЛЕДУЮЩЕГО рабочего часа.
    //Например, если работа длится 1 час и номер рабочего часа суток равен 2, то начало работы будет 11:00, а конец 12:00.
    // Эта функция используется только при записи результатов планирования в объект tasks

    int numday  = n / kolworkhoursday; // номер дня года, начиная с 0 (м.б. от 0 до 365*8)
    int numhour = n % kolworkhoursday; // номер рабочего часа суток (м.б. от 0 до 7 (kolhours-1))

    QDate date = beginyearplan.addDays(numday); // найденная астрономическая дата в формате QDate (beginyearplan - начало года планирования)
    QTime time(beginworkday + numhour,0);       // найденное астрономическое время начала часа в формате QTime. Минуты всегда = 0

    QDateTime datetime(date, time); // найденное астрономическое время начала часа в формате QDateTime

    // Проверка. Если нужен конец часа, то к найденному datetime прибавить 1 час (3600 секунд)
    if(str=="end") datetime = datetime.addSecs(3600) ; // прибавить 1 час, что бы было время конца часа

    return datetime;
}

int DateTimeToNumWorkHourYear(QDateTime &dt, QString &str) // перейти от даты QDateTime к номеру рабочего часа года
{
    // По дате (dt) в формате QDateTime найти номер рабочего часа года (от 0 до 365*8)
    // Если str == "begin", dt это астрономическое время начала рабочего часа,
    //если str == "end", то dt это астрономическое время НАЧАЛА следующего рабочего часа после последнего часа работы.

    int n;    // номер рабочего часа суток (от 0 до 7)

    QDate day  = dt.date(); // дата
    QTime time = dt.time(); // время

    //Проверка. Если dt - это время конца астрономического часа, то перейти ко времени начала часа
    if(str == "end") time = time.addSecs(-3600); // надо уменьшить время на 1 час (3600 секунд)

    int deyofyear = day.dayOfYear() - 1; // номер дня года, начиная с 0 (от 0 до 365)
    int hour      = time.hour();         // номер часа в сутках (от 0 до 23)

    // по номеру часа суток (от 0 до 23) перейти к номеру рабочего часа суток (от 0 до 7)
    if(hour <  beginworkday)  n = 0; // До начала рабочего дня с 0:00 до 8:00. Если 0,1,2,3,4,5,6,7,8, то будет 0-ой рабочий час (т.е. 9:00)
    else if(hour > (beginworkday + kolworkhoursday - 1)) n = kolworkhoursday; // После рабочего дня с 17:00 до 23:00. Если 17,18,19,20,21,22,23, то будет 0-ой час завтра
    else n = hour - beginworkday; // В течении рабочего дня c 9:00 до 16:00. Если 9,10,11,12,13,14,15,16 , то будет: 0, 1, 2, 3, 4, 5, 6 или 7

    int num = deyofyear * kolworkhoursday + n; // номер рабочего часа года (от 0 до 365*8)

    return num;
}

int TestTCarryTaskBeforePlanning(TCarryTaskList &tasks, QString &errs) // проверить объект tasks до планирования
{
    // Проверить данные объекта tasks до начала планирования, что бы выявить ошибки, которые не позволят начать планирование
    bool flerror = false; // флаг наличия обнаруженной ошибки в объекте tasks

    // Проверка. Есть ли проект?
    if(!tasks.count()){
        flerror = true; // признак наличия ошибки
        numerror ++; // порядковый номер ошибки
        errs += QString("<br><br><b>%1</b>. Не найден проект").arg(numerror);
    }

    int kolplan = 0; // счетчик считанных планов. Если он останется = 0, то прервать планирование (даже, если ошибок не обнаружено)
    foreach (TCarryTask *curTask,tasks) // цикл перебора проектов
    {
        // Проверка. Есть ли проект?
        if(!curTask){
            flerror = true; // признак наличия ошибки
            numerror ++; // порядковый номер ошибки
            errs += QString("<br><b>%1</b>. Не найден проект").arg(numerror);
        }

        for(int i=0; i<=1; i++){ // цикл перебора продукций (План выпуска продукции (i=0) и План ОРД (i=1))
            TCarryPlan *plan;

            // Проверка. Это план выпуска продукции или ОРД?
            if(i==0) plan = curTask->carryPlan(); // план выпуска продукции
            else     plan = curTask->ordPlan();   // план ОРД

            if(!plan) continue; // пропустить пустую продукцию (пустой план)

            kolplan++; // счетчик считанных планов. Если счетчик останется нулевым, то прекратить планирование

            // Проверка. Определен ли год планирования проекта? Если нет, то прекратить планирование
            if(!curTask->year()){
                flerror = true; // признак наличия ошибки
                numerror ++; // порядковый номер ошибки
                errs += QString("<br><br><b>%1</b>. Пустой год планирования в проекте: %2. %3").arg(numerror).arg(curTask->num()).arg(curTask->name());
            }

            // Проверка. Минимально возможное время начала продукции д.б. меньше максимально возможного времени конца продукции.
            if(curTask->dtMinBegin()){ // если минимально возможное время начала проекта задано
                if(curTask->dtMaxEnd()){ // если максимально возможное время конца проекта задано
                    QDateTime beginmin = QDateTime(curTask->dtMinBegin()->date(), curTask->dtMinBegin()->time());
                    QDateTime endmax   = QDateTime(curTask->dtMaxEnd()->date(),   curTask->dtMaxEnd()->time());
                    if((beginmin != emptydate) && (endmax != emptydate)){ // если оба заданных времени не "пустые"
                        if(beginmin >= endmax){ // если время "начала" больше времени "конца"
                            flerror = true; // признак наличия ошибки
                            numerror ++; // порядковый номер ошибки
                            errs += QString("<br><br><b>%1</b>. Заданное время начала больше заданного времени конца проекта: %2. %3").
                                    arg(numerror).arg(curTask->num()).arg(curTask->name());
                        }
                    }
                }
            }

            // Проверка. Максимально возможное время конца продукции не может быть меньше текущего времени.
            if(curTask->dtMaxEnd()){ // если максимально возможное время конца проекта задано
                QDateTime datetimecurrent(QDate::currentDate(), QTime::currentTime()); // текущая дата-время
                QDateTime tend   = QDateTime(curTask->dtMaxEnd()->date(),   curTask->dtMaxEnd()->time()); // заданное максимально возможное время конца
                if(tend != emptydate){ // если заданное максимальное время конца не пустое
                    if(tend < datetimecurrent){ // если время "конца" меньше текущей даты
                        flerror = true; // признак наличия ошибки
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Текущее время превышает заданное время конца проекта: %2. %3").
                                arg(numerror).arg(curTask->num()).arg(curTask->name());
                    }
                }
            }

            foreach (TCarryProcedure *proc,plan->procedures()) // цикл перебора процедур
            {
                // Проверка. Процедура не должна быть пустой. Должна содержать хотя бы одну задачу
                //if(proc->){
                //    flerror = true; // признак наличия ошибки
                //    numerror ++; // порядковый номер ошибки
                //    errs += QString("<br><b>%1</b>. Пустой список исполнителей в процедуре: %2.%3.%4").arg(numerror).arg(curTask->num()).arg(plan->num()).arg(proc->num());
                //}

                // Проверка. Если список возможных исполнителей незащищенной процедуры пуст, то прекратить планирование
                if(proc->possibleEmployees().empty()){ // если список возможных исполнителей - пустой
                    if(proc->isVolatile()){ // если процедура не защищена
                        flerror = true; // признак наличия ошибки
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Отсутствуют привлекаемые специалисты в процедуре: %2. %3 / %4. %5 / %6. %7").
                                arg(numerror).
                                arg(curTask->num()).arg(curTask->name()).
                                arg(plan->   num()).arg(plan->   name()).
                                arg(proc->   num()).arg(proc->   name());
                    }
                }

                // Проверка. Если у процедуры есть назначенный исполнитель, то этот исполнитель должен иметь календарь
                if(proc->employee()){
                    if(!proc->employee()->calendar()){ // проверка на пустой календарь
                        flerror = true; // признак наличия ошибки
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Отсутствует календарь исполнителя: %2 в процедуре: %3. %4 / %5. %6 / %7. %8").
                                arg(numerror).arg(proc->employee()->name()).
                                arg(curTask->num()).arg(curTask->name()).
                                arg(plan->   num()).arg(plan->   name()).
                                arg(proc->   num()).arg(proc->   name());
                    }
                }

                // Проверка. Каждый возможный исполнитель процедуры должен иметь календарь
                foreach (TEmployee *empl, proc->possibleEmployees()) { // цикл перебора возможных исполнителей процедуры
                    if(!empl->calendar()){ // проверка на пустой календарь
                        flerror = true; // признак наличия ошибки
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Отсутствует календарь возможного исполнителя: %2 в процедуре: %3. %4 / %5. %6 / %7. %8").
                                arg(numerror).arg(empl->name()).
                                arg(curTask->num()).arg(curTask->name()).
                                arg(plan->   num()).arg(plan->   name()).
                                arg(proc->   num()).arg(proc->   name());
                    }
                }

                foreach (TCarryWork *work,proc->works()){ // цикл перебора работ
                    if(work){ // проверка на нулевой указатель
                        // Проверка. Любая работа должна иметь time - длительность
                        if(!work->planPeriod()){
                            flerror = true; // признак наличия ошибки
                            numerror ++; // порядковый номер ошибки
                            errs += QString("<br><br><b>%1</b>. Не определена длительность работы: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                                    arg(numerror).
                                    arg(curTask->num()).arg(curTask->name()).
                                    arg(plan->   num()).arg(plan->   name()).
                                    arg(proc->   num()).arg(proc->   name()).
                                    arg(work->   num()).arg(work->   name());
                        }
                    }
                    else { // пустая работа
                        flerror = true; // признак наличия ошибки
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Обнаружена пустая работа: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                                arg(numerror).
                                arg(curTask->num()).arg(curTask->name()).
                                arg(plan->   num()).arg(plan->   name()).
                                arg(proc->   num()).arg(proc->   name()).
                                arg(work->   num()).arg(work->   name());
                    }
                } // конец цикла перебора работ

            } // конец цикла перебора процедур
        } // конец цикла перебора 2-ух планов: продукции и ОРД
    } // конец цикла перебора продукций

    // Проверка. Был ли считан хотя бы один план?
    if(!kolplan){
        flerror = true; // признак наличия ошибки
        numerror ++; // порядковый номер ошибки
        errs += QString("<br><br><b>%1</b>. Не найден ни один план").arg(numerror);
    }

    // Проверка. Были ли ошибки при проверке tasks?
    if(flerror) return 1; // есть ошибки. Планирование отменяется
    else return 0;        // норм. завершение функции. Ошибок - нет
}

int TestTCarryTaskAfterPlanning(TCarryTaskList &tasks, QString &errs) // проверить объект tasks после планирования
{
    // Проверить данные объекта tasks после записи в него результатов планирования.
    bool flerror = false; // признак наличия ошибки

    foreach (TCarryTask *curTask,tasks) // цикл перебора проектов
    {
        for(int i=0; i<=1; i++){ // цикл перебора продукций (План выпуска продукции (i=0) и План ОРД (i=1))
            TCarryPlan *plan;

            // Проверка. Это план выпуска продукции или ОРД?
            if(i==0) plan = curTask->carryPlan(); // план выпуска продукции
            else     plan = curTask->ordPlan();   // план ОРД

            if(!plan) continue; // пропустить пустую продукцию (пустой план)

            foreach (TCarryProcedure *proc,plan->procedures()) // цикл перебора процедур
            {
                foreach (TCarryWork *work,proc->works()) // цикл перебора работ
                {
                    // Проверка. Время конца работы д.б. больше времени начала работы (равенство не допускается)
                    QDateTime tbegin = QDateTime(work->dtPlanBegin()->date(), work->dtPlanBegin()->time());
                    QDateTime tend   = QDateTime(work->dtPlanEnd()->date(),   work->dtPlanEnd()->time());

                    if(tbegin >= tend){
                        flerror = true; // признак наличия ошибки
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Время начала работы больше или равно времени конца работы: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                                arg(numerror).
                                arg(curTask->num()).arg(curTask->name()).
                                arg(plan->   num()).arg(plan->   name()).
                                arg(proc->   num()).arg(proc->   name()).
                                arg(work->   num()).arg(work->   name());
                    }

                } // конец цикла перебора работ
            } // конец цикла перебора процедур
        } // конец цикла перебора 2-ух планов: продукции и ОРД
    } // конец цикла перебора продукций

    // Проверка. Были ли ошибки при проверке tasks?
    if(flerror) return 1; // есть ошибки. Планирование отменяется
    else return 0;        // норм. завершение функции. Ошибок - нет
}

int TestJobBeforePlanning(QString &errs) // тестировать job до планирования
{
    // Проверка на корректность данных в векторе job, считанных из tasks

    // Проверка. Есть ли что то в векторе job?
    if(!job.size()){ // если нет продукций
        numerror ++; // порядковый номер ошибки
        errs += QString("<br><br><b>%1</b>. Не найден план (продукция)").arg(numerror);
        return 1;
    }

    // Проверка на существование вектора об исполнителях executor. Возникала ошибка при пустых проектах
//    if(executor.size() == 0) {
//        if(flprint>=1) qDebug()<<"Ошибка. Вектор executor (сведения об исполнителях) пустой";
//        numerror ++; // порядковый номер ошибки
//        errs += QString("<br><b>%1</b>. Не найден ни один исполнитель").arg(numerror);
//        return 1;
//    }

    // Проверка. Проверка на "реальность" найденного года начала планирования (beginyearplan)?
    if((beginyearplan < QDate(2000, 1, 1)) | (beginyearplan > QDate(2040, 1, 1))){
        numerror ++; // порядковый номер ошибки
        errs += QString("<br><br><b>%1</b>. Неверная дата начала всех планов: %2").arg(numerror).arg(beginyearplan.toString("d.M.yyyy"));
        return 1;
    }

    // Проверка id исполнителя в векторе executor. Не должен быть равен 0
    for(int i=0; i<(int)executor.size(); ++i){
        if(executor[i].id == 0) {
            numerror ++; // порядковый номер ошибки
            errs += QString("<br><br><b>%1</b>. Обнаружен исполнитель с пустым идентификатором (id)").arg(numerror);
            return 2;
        }
    }

    // Проверка на уникальность id всех возможных исполнителей
    for(int i=0; i<(int)executor.size(); ++i){ // цикл перебора всех исполнителей
        int tekid = executor[i].id;
        for(int j=0; j<(int)executor.size(); ++j){ // цикл поиска текущего кода tekcode
            if(j==i) continue; // пропустить проверямого исполнителя
            if(executor[j].id == tekid) { // обнаружена ошибка - повторение кода исполнителя
                numerror ++; // порядковый номер ошибки
                errs += QString("<br><br><b>%1</b>. Нарушена уникальность id исполнителей").arg(numerror);
                return 3;
            }
        } // конец цикла поиска текущего кода tekcode
    } // конец цикла перебора всех исполнителей

    // Проверка. Есть хотя бы один проект?
    if(!job.size()) {
        numerror ++; // порядковый номер ошибки
        errs += QString("<br><br><b>%1</b>. Не найден проект").arg(numerror);
        return 15;
    }
    for(int i=0; i<(int) job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int) job[i].size(); ++j){ // цикл перебора процедур текущей продукции
            for(int k=0; k<(int) job[i][j].size(); ++k){ // цикл перебора работ текущей продукции

            // Работа должна иметь time - "продолжительность". Не допускается time=0
            if(!job[i][j][k].time) {
                numerror ++; // порядковый номер ошибки
                errs += QString("<br><br><b>%1</b>. Не найдена продолжительность работы: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                        arg(numerror).
                        arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                        arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                        arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename).
                        arg(job[i][j][k].num).         arg(job[i][j][k].name);
                return 6;
            }

            // Работа должна иметь список возможных исполнителей
            if(!job[i][j][k].people.size()) {
                numerror ++; // порядковый номер ошибки
                errs += QString("<br><br><b>%1</b>. Пустой список возможных исполнителей работы: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                        arg(numerror).
                        arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                        arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                        arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename).
                        arg(job[i][j][k].num).         arg(job[i][j][k].name);
                return 7;
            }

            // Время конца работы д.б. больше или равно времени начала
            if(job[i][j][k].begin > job[i][j][k].end) {
                numerror ++; // порядковый номер ошибки
                errs += QString("<br><b>%1</b>. Время начала больше времени конца работы: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                        arg(numerror).
                        arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                        arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                        arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename).
                        arg(job[i][j][k].num).         arg(job[i][j][k].name);
                return 11;
            }

            // Проверка защищенных работ. У этих работ д.б. заполнены поля: begin, end, executor
            //if(job[i][j][k].protection) {
            //    // Д.б. заполнен исполнитель (поле executor)
            //    if(job[i][j][k].executor.id == 0) {
            //        if(flprint>=1) qDebug()<<"Ошибка. Защищенная работа. Вектор job, поле executor.code=0 (пустое). i: "<<QString::number(i)<<", j: "<<QString::number(j);
            //        numerror ++; // порядковый номер ошибки
            //        errs += QString("<br><b>%1</b>. В защищенной работе пустой исполнитель").arg(numerror);
            //        return 10;
            //    }
            //}

            } // конец цикла перебора работ
        } // конец цикла перебора продукций
    } // конец цикла перебора продукций

    // Проверка на уникальность id всех работ (во всех проектах, планах, процедурах, т.е. во всем комплексе работ)
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур текущей продукции
            for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ текущей процедуры
                int tekid = job[i][j][k].id;
                for(int ii=0; ii<(int)job.size(); ++ii){ // цикл перебора продукций
                    for(int jj=0; jj<(int)job[ii].size(); ++jj){ // цикл перебора процедур текущей продукции
                        for(int kk=0; kk<(int)job[ii][jj].size(); ++kk){ // цикл перебора работ текущей процедуры
                            if((j==jj) && (i==ii) && (k==kk)) continue; // пропустить проверямую работу
                            if(job[ii][jj][kk].id==tekid) {
                                numerror ++; // порядковый номер ошибки
                                errs += QString("<br><br><b>%1</b>. Нарушение уникальности id работы: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                                        arg(numerror).
                                        arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                                        arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                                        arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename).
                                        arg(job[i][j][k].num).         arg(job[i][j][k].name);
                                return 12; // вернуть код "ошибки"
                            }
                        } // конец цикла перебора работ
                    } // конец цикла перебора процедур
                } // конец цикла перебора продукции
            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла перебора продукций

    // Проверка. Если в одной процедуре есть несколько защищенных работ, то все эти защищенные работы должны иметь одного и того же
    //назначенного исполнителя. Одну процедуру обязательно выполняет только один исполнитель
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур текущей продукции
            int tekidexecutor = 0; // id текущего исполнителя защищенной работы в процедуре
            for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ текущей процедуры
                if(!job[i][j][k].protection) continue; // пропустить незащищенную работу. Проверять только защищенные работы
                // если это первая встретившаяся защишенная работа процедуры, то запомнить ее исполнителя
                if(tekidexecutor == 0) tekidexecutor = job[i][j][k].executor.id; // запомнить первого исполнителя защищенной работы
                else{ // если это не первый исполнитель защищенной работы, то сравнить его с предыдущим
                    if(job[i][j][k].executor.id != tekidexecutor){ // разные исполнители в защищенных работах одной процедуры
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Недопустимы различные исполнители защищенных работ в одной процедуре: %2. %3 / %4. %5 / %6. %7").
                                arg(numerror).
                                arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                                arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                                arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename);
                        return 13; // вернуть код "ошибки"
                    }
                }
            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла перебора продукций

    //ВАЖНО. Сейчас id процедур повторяются в разных продукциях! Эта проверка не проходит
    // Проверка на уникальность id процедур (среди всех процедур ВСЕХ продукций)
    //for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
    //    for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур текущей продукции
    //        int tekid = job[i][j][0].procedureid; // запомнить id текущей процедуры (взять из начальной работы процедуры)
    //        for(int ii=0; ii<(int)job.size(); ++ii){ // цикл перебора продукций
    //            for(int jj=0; jj<(int)job[ii].size(); ++jj){ // цикл перебора процедур текущей продукции
    //                if((j==jj) && (i==ii)) continue; // пропустить проверямую процедуру
    //                if(job[ii][jj][0].procedureid == tekid) {
    //                    numerror ++; // порядковый номер ошибки
    //                    errs += QString("<br><br><b>%1</b>. Нарушение уникальности id процедуры: %2. %3 / %4. %5 / %6. %7, id=%10").
    //                            arg(numerror).
    //                            arg(job[i][j][0].projectnum).  arg(job[i][j][0].projectname).
    //                            arg(job[i][j][0].productnum).  arg(job[i][j][0].productname).
    //                            arg(job[i][j][0].procedurenum).arg(job[i][j][0].procedurename).arg(job[i][j][0].procedureid);
    //                    return 14; // вернуть код "ошибки"
    //                }
    //            } // конец цикла перебора процедур
    //        } // конец цикла перебора продукции
    //    } // конец цикла перебора процедур
    //} // конец цикла перебора продукций

    // Проверка на уникальность id процедур (среди всех процедур только ОДНОЙ продукции). Среди ВСЕХ продукций id процедур может повторяться
//    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
//        for(int j=0; j<(int)job[i].size(); ++j){ // первичный цикл перебора процедур текущей продукции
//            int tekid = job[i][j][0].procedureid; // запомнить id текущей (проверяемой) процедуры (взять из начальной работы процедуры)
//            for(int jj=0; jj<(int)job[i].size(); ++jj){ // вторичный цикл перебора процедур текущей продукции
//                if(j==jj) continue; // пропустить проверямую процедуру в i-ой продукции
//                if(job[i][jj][0].procedureid == tekid) { // если найден повторно id. (т.е. нарушена уникальность id процедур в рамках одной продукции)
//                    numerror ++; // порядковый номер ошибки
//                    errs += QString("<br><br><b>%1</b>. Нарушение уникальности id процедуры: %2. %3 / %4. %5 / %6. %7, id=%10").
//                            arg(numerror).
//                            arg(job[i][j][0].projectnum).  arg(job[i][j][0].projectname).
//                            arg(job[i][j][0].productnum).  arg(job[i][j][0].productname).
//                            arg(job[i][j][0].procedurenum).arg(job[i][j][0].procedurename).arg(job[i][j][0].procedureid);
//                    return 14; // вернуть код "ошибки"
//                }
//            } // конец вторичного цикла перебора процедур
//        } // конец первичного цикла перебора процедур
//    } // конец цикла перебора продукций

    // Проверка. Во всех работах начальной процедуры продукции список опорных процедур (prevprocedurenum) д.б. пустым.
    //В работах всех остальных процедур этот список м.б. пустым или заполнен.
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур текущей продукции
            // Проверка. Это начальная процедура?
            if(!j){ // если процедура начальная
                for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ текущей процедуры
                    if(!job[i][j][k].prevprocedurenum.empty()) { // если список опорных процедур НЕ пустой для начальной процедуры
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Список опорных процедур д.б. пустым для начальной процедуры: %2. %3 / %4. %5 / %6. %7").
                                arg(numerror).
                                arg(job[i][j][0].projectnum).  arg(job[i][j][0].projectname).
                                arg(job[i][j][0].productnum).  arg(job[i][j][0].productname).
                                arg(job[i][j][0].procedurenum).arg(job[i][j][0].procedurename);
                        return 15; // вернуть код "ошибки"
                    }
                } // конец цикла перебора работ
            }
        } // конец цикла перебора процедур
    } // конец цикла перебора продукций

    // Проверка "упорядочивания". Каждая процедура может опираться только на процедуру с меньшим порядковым номером. Если это не выполняется - это
    //ошибка шаблона. Надо менять последовательность (провести упорядочивание) процедур в шаблоне. Т.е. в списке опорных процедур могут быть
    //только меньшие индексы процедур, чем индекс проверяемой процедуры. Процедура не может опираться на "старшую" процедуру.
    // Здесь же проверяется, чтобы процедура не опиралась сама на себя.
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур текущей продукции
            for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ текущей процедуры
                for(int g=0; g<(int)job[i][j][k].prevprocedureind.size(); ++g){ // цикл перебора индексов опорных процедур
                    int tekind = job[i][j][k].prevprocedureind[g];     // получить индекс опорной процедуры
                    if(tekind >= j) { // если "младшая" процедура опирается на "старшую" или сама на себя - это ошибка
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Нарушение упорядочивания процедур. "
                                        "Индекс опорной процедуры превышает или равен индексу самой процедуры: %2. %3 / %4. %5 / %6. %7").
                                arg(numerror).
                                arg(job[i][j][0].projectnum).  arg(job[i][j][0].projectname).
                                arg(job[i][j][0].productnum).  arg(job[i][j][0].productname).
                                arg(job[i][j][0].procedurenum).arg(job[i][j][0].procedurename);
                                return 17; // вернуть код "ошибки"
                    }
                } // конец цикла перебора индексов опорных процедур
            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла перебора продукций

    // Проверка на уникальность номера (num) процедур (среди всех процедур только ОДНОЙ продукции). Среди ВСЕХ продукций num процедур будет повторяться
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j){ // первичный цикл перебора процедур текущей продукции
            for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ текущей процедуры
                int teknum = job[i][j][k].procedurenum; // запомнить num текущей (проверяемой) процедуры
                for(int jj=0; jj<(int)job[i].size(); ++jj){ // вторичный цикл перебора процедур текущей продукции
                    for(int kk=0; kk<(int)job[i][jj].size(); ++kk){ // цикл перебора работ текущей процедуры
                        if(j==jj) continue; // пропустить проверямую процедуру в i-ой продукции
                        if(job[i][jj][kk].procedurenum == teknum) { // если найден повторно num. (т.е. нарушена уникальность num процедур в рамках одной продукции)
                            numerror ++; // порядковый номер ошибки
                            errs += QString("<br><br><b>%1</b>. Нарушение уникальности номера (num) процедуры: %2. %3 / %4. %5 / %6. %7, num=%10").
                                    arg(numerror).
                                    arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                                    arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                                    arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename).arg(job[i][j][k].procedurenum);
                            return 18; // вернуть код "ошибки"
                        }
                    }
                } // конец вторичного цикла перебора процедур
            } // конец первичного цикла перебора работ текущей процедуры
        } // конец первичного цикла перебора процедур
    } // конец цикла перебора продукций

    return 0; // нормальное завершение функции. Ошибок в исходных данных не обнаружено
}

int TestPlan(QString &errs) // тестировать job после планирования
{
    // Тестирование сформированного плана на ошибки. Тестирование вектора job после планирования

    //Проверка выполнения принципа последовательности выполнения работ одной продукции. Каждая последующая работа должна
    //начинается только после завершения предыдущей
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур
            for(int k=0; k<(int)job[i][j].size()-1; ++k) { // цикл перебора работ, кроме последней
                // Проверка. Работа начинается раньше, чем закончилась предыдущая?
                if(job[i][j][k].end > job[i][j][k+1].begin){
                    numerror ++; // порядковый номер ошибки
                    errs += QString("<br><br><b>%1</b>. Нарушение принципа последовательности для работы: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                            arg(numerror).
                            arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                            arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                            arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename).
                            arg(job[i][j][k].num).         arg(job[i][j][k].name);
                    return 1;
                }
            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла перебора продукций

    // Проверка на дублирование одновременно выполняемых работ одним исполнителем. Каждый исполнитель в любой момент времени
    //может выполнять только одну работу. Для внешних исполнителей такого требования - нет
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j) { // цикл перебора процедур
            for(int k=0; k<(int)job[i][j].size(); ++k) { // цикл перебора работ

                executor_type executor = job[i][j][k].executor; // запомнить проверямого исполнителя
                int begin = job[i][j][k].begin;                 // запомнить начало проверяемой работы
                int end   = job[i][j][k].end;                   // запомнить конец проверяемой работы

                if(executor.external) continue; // пропустить внешнего исполнителя (для него не надо проверять дублирование)

                // перебрать все работы для проверки
                for(int ii=0; ii<(int)job.size(); ++ii){ // цикл перебора продукций
                    for(int jj=0; jj<(int)job[ii].size(); ++jj) { // цикл перебора продукций
                        for(int kk=0; kk<(int)job[ii][jj].size(); ++kk) { // цикл перебора работ
                            if((i==ii) && (j==jj) && (k==kk)) continue; // пропустить проверямую работу (не проверять саму с собой)
                            if(job[ii][jj][kk].executor.id != executor.id) continue; // пропустить ненужного исполнителя
                            if(((begin>=job[ii][jj][kk].begin) && (begin<=job[ii][jj][kk].end)) || // точка begin проверяемого интервала попала внутрь текущего интервала
                               ((end  >=job[ii][jj][kk].begin) && (end  <=job[ii][jj][kk].end)) || // точка end   проверяемого интервала попала внутрь текущего интервала
                               ((begin<=job[ii][jj][kk].begin) && (end  >=job[ii][jj][kk].end))){  // проверяемый интервал полностью накрыл текущий интервал
                                QMessageBox::information(0,"Отладка2", "Дублирование работ. Исполнитель id=" + QString::number(executor.id) + " в работе с id=" + QString::number(job[ii][jj][kk].id));
                                numerror ++; // порядковый номер ошибки
                                errs += QString("<br><br><b>%1</b>. Дублирование исполнителя в работе: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                                        arg(numerror).
                                        arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                                        arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                                        arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename).
                                        arg(job[i][j][k].num).         arg(job[i][j][k].name);
                                return 2;
                            }
                        } // конец цикла перебора работ
                    } // конец цикла перебора продукций
                } // конец цикла перебора продукции

            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла перебора продукций

    // Проверка. Начало работы не может превышать конца той же работы (равенство начала и конца допускается, если работа длится 1 час)
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур
            for(int k=0; k<(int)job[i][j].size(); ++k) { // цикл перебора работ
                if(job[i][j][k].begin > job[i][j][k].end){
                    numerror ++; // порядковый номер ошибки
                    errs += QString("<br><br><b>%1</b>. Начало работы больше или равно концу работы: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                            arg(numerror).
                            arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                            arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                            arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename).
                            arg(job[i][j][k].num).         arg(job[i][j][k].name);
                    return 1;
                }
            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла перебора продукций

    // Проверка. Любая незащищенная работа должна начинаться позже текщего времени. Нельзя планировать в "прошлом".
    //Защищенные работы могут находиться в "прошлом".
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int) job[i].size(); ++j){ // цикл перебора процедур текущей продукции
            for(int k=0; k<(int) job[i][j].size(); ++k){ // цикл перебора работ текущей продукции
                if(job[i][j][k].protection) continue; // пропустить защищенную работу. Она может находиться в "прошлом"
                else { // проверяем незащищенную работу. Она не может находиться в "прошлом"
                    if(job[i][j][k].begin < tbeginplan){
                        numerror ++; // порядковый номер ошибки
                        errs += QString("<br><br><b>%1</b>. Ошибочное планирование работы в \"прошлом\". Работа: %2. %3 / %4. %5 / %6. %7 / %8. %9").
                                arg(numerror).
                                arg(job[i][j][k].projectnum).  arg(job[i][j][k].projectname).
                                arg(job[i][j][k].productnum).  arg(job[i][j][k].productname).
                                arg(job[i][j][k].procedurenum).arg(job[i][j][k].procedurename).
                                arg(job[i][j][k].num).         arg(job[i][j][k].name);
                        return 4;
                    }
                }
            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла перебора продукций

    // Проверка. Рассчитанное время начала продукции должно быть больше минимально разрешенного времени начала продукции
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        if(job[i][0][0].beginmin){ // если задано минимально разрешенное время начала продукции
            if(job[i][0][0].begin < job[i][0][0].beginmin){ // если рассчитанное время начала продукции меньше заданного времени начала продукции
                numerror ++; // порядковый номер ошибки
                errs += QString("<br><br><b>%1</b>. Рассчитанное время начала продукции меньше минимально заданного для проекта: %2. %3").
                        arg(numerror).arg(job[i][0][0].projectnum).arg(job[i][0][0].projectname);
                return 5;
            }
        }
    } // конец цикла перебора продукций

    // Проверка. Рассчитанное время конца продукции (любой из работ продукции) не может быть больше максимально разрешенного времени конца продукции
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        if(job[i][0][0].endmax){ // если задано максимально разрешенное время конца продукции
            if(job[i][0][0].end > job[i][0][0].endmax){ // если рассчитанное время конца продукции больше заданного времени конца продукции
                numerror ++; // порядковый номер ошибки
                errs += QString("<br><br><b>%1</b>. Рассчитанное время конца продукции больше максимально заданного для проекта: %2. %3").
                        arg(numerror).arg(job[i][0][0].projectnum).arg(job[i][0][0].projectname);
                return 6;
            }
        }
    } // конец цикла перебора продукций

    return 0; // ошибок нет
}

void FindBeginEndJob(executor_type &executor, int &tstart, int &time, int &tbegin, int &tend) // прямое планирование
{
    // Прямое планирование. Для исполнителя executor найти время начала и время конца работы с учетом нерабочих
    //часов (праздников, выходных, отпусков и т.д.)
    //    Входные параметры:
    //tstart - время, начиная с которого, надо искать допустимое начало работы tbegin;
    //time   - заданное полное время выполнения работы;
    //    Выходные параметры:
    //tbegin - найденное время начала работы с учетом нерабочих часов;
    //tend   - найденное время конца работы с учетом нерабочих часов.

    int sum=0; // счетчик найденных рабочих часов
    int ttek = tstart; // проверяемый час
    while(sum <= time){ // цикл, пока не найдено нужное количество рабочих часов time
        // проверка. Является ли час ttek нерабочим?
        int kol = executor.rest.count(ttek); // поиск ttek - нужного часа среди списка нерабочих часов
        if(kol == 0) { // проверяемый час - рабочий? (т.к. он не найден среди списка нерабочих часов)
            ++sum; // счетчик найденных рабочих часов
            if(sum == 1)    tbegin = ttek; // запомнить первый найденный рабочий час, как tbegin
            if(sum == time) tend   = ttek; // запомнить последний найденный рабочий час, как tend
        }
        ++ttek; // переход к следующему часу для его проверки. Двигаемся слева направо
    }
}

void FindEndBeginJob(executor_type &executor, int &tstart, int &time, int &tbegin, int &tend) // обратное планирование
{
    // Обратное планирование. Для исполнителя executor найти время конца и время начала работы с учетом нерабочих часов (праздников, выходных, отпусков и т.д.)
    //    Входные параметры:
    //tstart - время, начиная с которого, надо искать допустимое начало работы tbegin;
    //time   - заданное полное время выполнения работы;
    //    Выходные параметры:
    //tbegin - найденное время начала работы с учетом нерабочих часов;
    //tend   - найденное время конца работы с учетом нерабочих часов.

    int sum=0; // счетчик найденных рабочих часов
    int ttek = tstart; // проверяемый час
    while(sum <= time){ // цикл, пока не найдено нужное количество рабочих часов time
        // проверка. Является ли час ttek нерабочим?
        int kol = executor.rest.count(ttek); // поиск ttek - нужного часа среди списка нерабочих часов
        if(kol == 0) { // проверяемый час - рабочий? (т.к. он не найден среди списка нерабочих часов)
            ++sum; // счетчик найденных рабочих часов
            if(sum == 1)    tend = ttek; // запомнить найденный рабочий час, как tend
            if(sum == time) tbegin   = ttek; // запомнить найденный рабочий час, как tbegin
        }
        --ttek; // переход к следующему часу для его проверки. Двигаемся справа налево
    }
}

job_type FindJob(int &id) // найти работу в job по id
{
    // найти работу в векторе job по ее идентификатору id. Если работа не найдена, то вернуть пустую работу
    for(int i=0; i<(int)job.size(); i++){ // цикл перебора продукции
        for(int j=0; j<(int)job[i].size(); j++){ // цикл перебора процедур
            for(int k=0; k<(int)job[i][j].size(); k++){ // цикл перебора работ
                if(id == job[i][j][k].id) return job[i][j][k];
            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла перебора продукции

    // Не найдена работа. Это ошибка. Работа по id должна быть найдена всегда
    //qDebug()<<"Ошибка. В векторе job не найдена работа с id: " + QString::number(id);
    job_type wortempty; // сформировать и вернуть пустую работу
    return wortempty;
}

void SortingVectorJob() // сортировать продукции в job
{
    // Сортировка вектора job[i][j][k] в соответствии с приоритетами продукций (в порядке убывания приоритета). i-индекс продукции.
    //"Самая верхняя" продукция (для i=0) должна иметь высший приоритет. "Самая нижняя" продукция с наименьшим приритетом будет
    //получать ресурсы (выделяемое время и исполнителей) по остаточному принципу. Чем больше приоритет продукции ("выше" продукция), тем
    //быстрее она будет выполнена

    int kol; // количество перестановок местами продукций при нарушении приоритета
    do {
        kol = 0; // количество перестановок
        for(int i=0; i<=(int)job.size() - 2; ++i){ // цикл перебора продукций (до предпоследней включительно)
            // Проверка. Есть нарушение приоритета? Если Да, то переставить продукции местами
            if(job[i][0][0].priority < job[i+1][0][0].priority){ // проритет взять из начальной работы каждой продукции
                kol = kol + 1;
                QVector<QVector<job_type>> producttemp = job[i]; // запомнить i-ую продукцию
                job[i] = job[i+1];                               // заменить i-ую продукцию на (i+1)-ую продукцию
                job[i+1] = producttemp;                          // получить (i+1)-ую продукцию
            }
        } // конец цикла перебора продукций (до предпоследней)
    } while(kol > 0);
}

void FillVectorJob(TCarryTaskList &tasks) // заполнить job данными
{
    // функция "заполнить вектор работ" извлекает из принятого параметра tasks все необходимые сведения по всеми проектам,
    //продукциям, процедурам и работам. Заполняет вектор job, необходимый для планирования.
    // Вектор job[i][j][k] - трехмерный динамический массив, где i - индекс продукции, j - индекс процедуры, k - индекс работы.

    job.clear();      // предварительно очистить вектор работ
    executor.clear(); // предварительно очистить вектор исполнителей

    // Проверка. Есть ли что то в tasks?
    if(!tasks.count()) return;

    // Начало года планирования. Пока взять из начального проекта. Нужен минимальный их всех проектов
    beginyearplan = QDate(tasks[0]->year(), 1, 1); // начало года планирования в формате QDate (нужен для функции addDays())

    // прочитать данные tasks и записать их в рабочий вектор job, который является основным при планировании
    foreach (TCarryTask *curTask, tasks){ // цикл перебора проектов

        // Проверка. Есть ли проект?
        if(!curTask) continue;

        // Поиск beginyearplan - начала самого раннего года планирования из всех планов в базе. От него начнется отсчет всех времен
        if(beginyearplan > QDate(curTask->year(), 1, 1)) beginyearplan = QDate(curTask->year(), 1, 1); //нужен для функции addDays()

        // План выпуска продукции и План выпуска ОРД - это две разные продукции. Надо загрузить последовательно обе продукции.
        //В первом проходе считывается продукция "План выпуска продукции", а во втором проходе считывается продукция "План ОРД"
        for(int i=0; i<=1; i++){ // цикл перебора продукций (двух планов): План выпуска продукции (i=0) и План ОРД (i=1)
            TCarryPlan *plan;

            // Проверка продукции. Это план выпуска продукции или план ОРД? Каждый план это продукция
            if(i==0) plan = curTask->carryPlan(); // план выпуска продукции
            else     plan = curTask->ordPlan();   // план ОРД

            // Проверка. Есть ли план (продукция)?
            if(!plan) continue;

            // Проверка. Если нет плана (продукции), то пропустить его
            if(!plan->procedures().size()) continue; // пропустить план (продукцию), в котором нет процедур

            QVector<QVector<job_type>> tempvectorproc; // временный вектор процедур
            foreach (TCarryProcedure *proc, plan->procedures()){ // цикл перебора процедур

                // Проверка. Есть ли процедура? Проверка на нулевой указатель
                if(!proc) continue;

                QVector<job_type> tempvectorwork; // временный вектор работ
                foreach (TCarryWork *work, proc->works()){ // цикл перебора работ

                    // Проверка. Есть ли работа?
                    if(!work) continue;

                    // Проверка "плохой" работы. Если в защищенной работе не заполнены: начало или конец или исполнитель, то
                    //такую работу пропустить и не загружать в вектор job. Такая работа не будет участвовать в планировании и
                    //эта работа не будет проверяться на дублирование. В объекте tasks такая работа останется без изменений
                    if(!work->isVolatile()){ // если работа защищена (false)
                        if(!work->dtPlanBegin()) continue; // пропустить защищенную работу с незаполненной датой начала
                        if(!work->dtPlanEnd())   continue; // пропустить защищенную работу с незаполненной датой конца
                        if(!proc->employee())    continue; // пропустить защищенную работу с незаполненным исполнителем
                    }

                    // Сформировать текущую работу jobtemp для записи ее в вектор работ job
                    job_type jobtemp;

                    // Заполнить реквизиты работы jobtemp (любой работы: защищенной или незащищенной)
                    jobtemp.id            = work->id();          // id идентификатор работы (из БД. Нужен для записи результатов планирования)
                    jobtemp.priority      = curTask->priority(); // приоритет работы взять из приоритета проекта (для сортировки вектора job)

                    jobtemp.num           = work->num();         // номер работы (только для сообщения об ошибке)
                    jobtemp.name          = work->name();        // наименование работы (только для сообщения об ошибке)

                    jobtemp.procedurenum  = proc->num();         // номер процедуры, которой принадлежит данная работа (только для сообщения об ошибке)
                    jobtemp.procedurename = proc->name();        // наименование процедуры, которой принадлежит данная работа (только для сообщения об ошибке)

                    // Заполнить список номеров опорных процедур
                    if(proc->linkedElements().size()){ // если список заполнен
                        QList<int>::iterator p = proc->linkedElements().begin(); // итератор для перебора списка номеров опорных процедур
                        while (p != proc->linkedElements().end()) { // цикл чтения списка номеров опорных процедур
                            jobtemp.prevprocedurenum.push_back(*p); // записать номер опорной процедуры в вектор job
                            p++;
                        } // конец цикла чтения списка номеров опорных процедур
                    }

                    jobtemp.productnum    = plan->num();         // номер продукции, которой принадлежит данная работа (только для сообщения об ошибке)
                    jobtemp.productname   = plan->name();        // наименование продукции, которой принадлежит данная работа (только для сообщения об ошибке)

                    jobtemp.projectnum    = curTask->num();      // номер проекта, которому принадлежит данная работа (только для сообщения об ошибке)
                    jobtemp.projectname   = curTask->name();     // наименование проекта, которому принадлежит данная работа (только для сообщения об ошибке)

                    QDateTime datetime; // временная дата

                    // Заполнить beginmin - минимально разрешенное время начала работы (от 0 до 365*8)
                    //Проверка. Задана ли минимально разрешенное время начала продукции?
                    if(curTask->dtMinBegin()){
                        datetime = QDateTime(curTask->dtMinBegin()->date(), curTask->dtMinBegin()->time());
                        jobtemp.beginmin = DateTimeToNumWorkHourYear(datetime, begin);
                        //Проверка дополнительная. Если минимально разрешенное время начала продукции очищено пользователем?
                        if(*(curTask->dtMinBegin()) == emptydate){
                            jobtemp.beginmin = 0;
                        }
                    }
                    else jobtemp.beginmin = 0;

                    // Заполнить endmax - максимально разрешенное время конца работы (от 0 до 365*8)
                    //Проверка. Задана ли максимально разрешенное время конца продукции?
                    if(curTask->dtMaxEnd()){ // проверка. Задана ли максимально разрешенное время конца продукции?
                        datetime = QDateTime(curTask->dtMaxEnd()->date(), curTask->dtMaxEnd()->time());
                        jobtemp.endmax = DateTimeToNumWorkHourYear(datetime, end);
                        //Проверка дополнительная. Если максимально разрешенное время конца продукции очищено пользователем?
                        if(*(curTask->dtMaxEnd()) == emptydate){
                            jobtemp.endmax = 0;
                        }
                    }
                    else jobtemp.endmax = 0;

                    jobtemp.time         = work->planPeriod();  // время выполнение работы
                    jobtemp.protection   = !work->isVolatile(); // признак защиты работы

                    // Заполнить список возможных исполнителей работы jobtemp.people
                    foreach (TEmployee *empl, proc->possibleEmployees()) { // цикл перебора возможных исполнителей
                        int idtek = empl->id();   // id текущего исполнителя
                        executor_type executortemp; // структура нового исполнителя, которую надо заполнить, а затем сохранить
                        executortemp.id       = idtek;                   // записать код текущего исполнителя
                        executortemp.external = empl->role().isExtern(); // записать признак исполнителя (внешний/внутренний)
                        // Заполнить календарь возможных исполнителей процедуры нерабочими часами (не днями!) исполнителя
                        QList<int> calendar = *empl->calendar()->fullRestDates(); // календарь исполнителя, содержащий номера нерабочих дней года: выходные, праздники, отпуск (начиная с 0)
                        QList<int>::iterator p = calendar.begin(); // итератор для перебора списка calendar
                        while (p != calendar.end()) { // цикл перебора списка calendar (перебор номеров нерабочих дней года возможных исполнителей)
                            for(int j=0; j<kolworkhoursday; ++j){ // цикл перебора рабочих часов суток (от 0 до 7)
                                executortemp.rest.push_back(*p * kolworkhoursday + j); // календарь исполнителя, содержащий номера нерабочих часов года (по 8 часов в день)(начиная с 0)
                            } // конец цикла перебора рабочих часов суток
                            p++;
                        } // конец цикла перебора списка calendar
                        jobtemp.people.push_back(executortemp); // добавить текущего исполнителя executortemp в список возможных исполнителей работы
                        // Здесь же добавить текущего исполнителя executortemp в общий вектор всех исполнителей executor (исключив дублирование)
                        bool flfind = false; // признак, что исполнитель найден (true)
                        for(int i=0; i<(int)executor.size(); i++){ // цикл перебора вектора исполнителей
                            if(executor[i].id == idtek){ // исключить дублирование исполнителей в векторе executor
                                flfind = true;
                                break;
                            }
                        } // конец цикла перебора вектора исполнителей
                        if(!flfind) executor.push_back(executortemp); // доб. тек. исполнителя в вектор исполнителей executor
                    } // цикл перебора возможных исполнителей процедуры

                    // Заполнить оставшиеся реквизиты работы. Отдельно для защищенной работы и незащищенной работы
                    if(jobtemp.protection){ // защищенная работа. В ней ничего менять нельзя
                        jobtemp.changes = false; // признак того, что в защищенной работе изменений не будет

                        // Заполнить время начала работы
                        QDateTime datetime = QDateTime(work->dtPlanBegin()->date(), work->dtPlanBegin()->time());
                        jobtemp.begin = DateTimeToNumWorkHourYear(datetime, begin);  // начало работы. Номер рабочего часа года (от 0 до 365*8)

                        // Заполнить время конца работы
                        datetime = QDateTime(work->dtPlanEnd()->date(), work->dtPlanEnd()->time());
                        jobtemp.end = DateTimeToNumWorkHourYear(datetime, end);  // начало работы. Номер рабочего часа года (от 0 до 365*8)

                        jobtemp.executor.id = proc->employee()->id(); // заполнить код исполнителя

                        // Заполнить календарь уже назначенного ранее исполнителя процедуры (и работы) нерабочими часами (не днями!) исполнителя
                        QList<int> calendar = *proc->employee()->calendar()->fullRestDates(); // календарь исполнителя, содержащий номера нерабочих дней года: выходные, праздники, отпуск (начиная с 0)
                        QList<int>::iterator p = calendar.begin(); // итератор для перебора списка calendar
                        while (p != calendar.end()) { // цикл перебора списка calendar (перебор номеров нерабочих дней года назначенного исполнителя)
                            for(int j=0; j<kolworkhoursday; ++j){ // цикл перебора рабочих часов суток (от 0 до 7)
                                jobtemp.executor.rest.push_back(*p * kolworkhoursday + j); // календарь исполнителя, содержащий номера нерабочих часов года (по 8 часов в день)(начиная с 0)
                            } // конец цикла перебора рабочих часов суток
                            p++;
                        } // конец цикла перебора списка calendar

                        jobtemp.executor.external = proc->employee()->role().isExtern(); // внешний или внутренний исполнитель

                        // Проверка. Если в защищенной работе есть назначенный исполнитель, но список возможных исполнителей - пуст, то
                        //скопировать этого исполнителя в пустой список возможных исполнителей (, что бы не менять общий алгоритм)
                        if(jobtemp.people.empty()) jobtemp.people.push_back(jobtemp.executor);

                    }
                    else{ // незащищенная работа обнуляется перед планированием
                        jobtemp.changes           = true;      // признак того, что работа будет изменена (и продукция тоже)
                        jobtemp.begin             = 0;         // время начала работы
                        jobtemp.end               = 0;         // время конца работы
                        jobtemp.executor.id       = 0;         // пока исполнителя нет
                        jobtemp.executor.rest     = {};        // пока календаря исполнителя нет
                        jobtemp.executor.external = false;     // Пока так. Это поле будет заполнено позднее, при планировании
                    }
                    tempvectorwork.push_back(jobtemp); // записать текущую работу в вектор работ
                } // конец цикла перебора работ
                tempvectorproc.push_back(tempvectorwork); // записать заполненный вектор работ в вектор процедур
                ++kolproc; // счетчик общего числа процедур, записанных в вектор job (для установки ProgressDialog)

            } // конец цикла перебора процедур
            job.push_back(tempvectorproc); // записать заполненный вектор процедур в вектор продукций
        } // конец цикла перебора 2-ух планов: продукции и ОРД.
    } // конец цикла перебора продукций

    pprd->setMaximum(kolproc); // установить максимальное значение индикатора прогресса QProgressDialog, т.к. "считать"
    //будем процедуры, а не работы. Количество обрабатываемых процедур всегда постоянно, а количество обрабатываемых работ
    //будет меняться в зависимости от количества возможных исполнителей
}

int ProcedureNumToInd(int &i, int &num)
{
    // В рамках i-ой продукции, зная num процедуры, найти и вернуть индекс этой процедуры.
    //Индекс процедуры определяется общим порядком процедур в шаблоне (плане), начиная с 0.

    int ind = -1; // начальное (заранее неверное, отрицательное) значение индекса, которое надо найти

    for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур i-ой продукции
        for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ текущей процедуры
            int teknum = job[i][j][k].procedurenum;     // получить num текущей процедуры
            if(num == teknum){ // нашли процедуру с нужным num
                ind = j; // запомнить индекс нужной процедуры
                break;   // прервать все циклы
            }
        } // конец цикла перебора работ
    } // конец цикла перебора процедур

    if(ind == -1) qDebug()<<"Ошибка. Не найдена опорная процедура с num="<<QString::number(num);
    return ind; // вернуть найденный индекс искомой процедуры
}

void FillVectorJobIndPrevProcedure() // заполнить в векторе job индексы опорных процедур
{
    // В векторе job зная номера (num) опорных процедур (job[i][j][k].prevprocedurenum) заполнить
    //индексы опорных процедур (job[i][j][k].prevprocedureind)
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур текущей продукции
            for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ текущей процедуры
                for(int g=0; g<(int)job[i][j][k].prevprocedurenum.size(); ++g){ // цикл перебора num опорных процедур
                    int teknum = job[i][j][k].prevprocedurenum[g];     // получить num текущей опорной процедуры
                    int tekind = ProcedureNumToInd(i, teknum);         // в i-ой продукции, перейти от num процедуры к индексу этой процедуры
                    job[i][j][k].prevprocedureind.push_back(tekind); // заполнить список индексов опорных процедур - prevprocedureind
                } // конец цикла перебора num опорных процедур
            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла перебора продукций
}

void CorrectionProcedure() // проверить возможных исполнителей процедур
{
    // Если в рамках одной процедуры встретилась хотя бы одна защищенная работа, то надо очистить списки возможных исполнителей
    //во всех работах и занести в эти списки только одного заданного исполнителя этой защищенной работы.
    // Это страховка от возможных ошибок манипуляций оператора с признаком защищенностью работ.
    // Это гарантирует, что все работы одной процедуры будет высполнять только один исполнитель.
    // Если в процедурах нет защищенных работ, то эта функция ничего не делает.
    // Если в процедуре есть несколько защищенных работ с разными исполнителями - это ошибка, она будет раньше обнаружена в TestData()

    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукций
        for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур текущей продукции

            bool flprotection = false;        // флаг наличия в текущей процедуре защищенной работы (пока нет защищенных работ)
            executor_type executorprotection; // назначенный исполнитель защищенной работы (пока не найден)

            for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ текущей процедуры
                if(job[i][j][k].protection) { // если найдена защищенная работа
                    flprotection = true;   // установить признак, что найдена защищенная работа
                    executorprotection = job[i][j][k].executor; // запомнить найденного исполнителя защищенной работы
                    break; // преркратить цикл перебора работ текущей продукции, т.к. нашли защищенную работу
                }
            } // конец цикла перебора работ

            // Проверка. Была ли найдена защищенная работа в текущей продукции?
            if(flprotection){ // была найдена защищенная работа
                for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ текущей процедуры
                    job[i][j][k].people.clear(); // очистить список возможных исполнителей всех работ продукции
                    job[i][j][k].people.push_back(executorprotection); // записать в список всех работ найденного исполнителя
                } // конец цикла перебора работ
            }

        } // конец цикла перебора процедур
    } // конец цикла перебора продукций

}

void PrinTCarryTask(TCarryTaskList &tasks) // вывести в консоль tasks
{
    // вывести в консоль содержимое tasks (только для отладки)
    foreach (TCarryTask *curTask,tasks) // цикл перебора проэктов
    {
        qDebug().noquote()<<"Проект name="<<curTask->name();
        qDebug()<<"id="<<curTask->id();
        qDebug()<<"priority="<<curTask->priority();

        if(curTask->dtMinBegin()) qDebug()<<"dtMinBegin="<<curTask->dtMinBegin()->date()<<curTask->dtMinBegin()->time();
        else                      qDebug()<<"dtMinBegin=...";

        if(curTask->dtMaxEnd()) qDebug()<<"dtMaxEnd="<<curTask->dtMaxEnd()->date()<<curTask->dtMaxEnd()->time();
        else                    qDebug()<<"dtMaxEnd=...";

        for(int i=0; i<=1; i++){ // цикл перебора двух продукций (планов): План выпуска продукции (i=0) и План ОРД (i=1)
            TCarryPlan *plan; // plan - это продукция

            // Проверка. Это план выпуска продукции или ОРД?
            if(i==0) plan = curTask->carryPlan(); // план выпуска продукции
            else     plan = curTask->ordPlan();   // план ОРД

            // Проверка. Есть ли продукция?
            if(!plan) continue; // пропустить пустую продукцию
            qDebug().noquote()<<"    Продукция (план) name="<<plan->name();
            qDebug()<<          "    id="<<plan->id();
            qDebug()<<          "    isSaved="<<plan->isSaved();

            foreach (TCarryProcedure *proc,plan->procedures()) // цикл перебора процедур продукции
            {
                qDebug().noquote()<<"        Процедура name="<<proc->name();
                qDebug()<<          "        id="<<proc->id();
                qDebug()<<          "        num="<<proc->num();
                qDebug()<<          "        isExtern="<<proc->isExtern(); // признак того, что процедура внешняя (не известы возможные исполнители)

                // вывести в цикле id возможных исполнителей процедуры
                if(proc->possibleEmployees().empty())                     qDebug()<<          "        possibleEmployees= ...";
                else foreach (TEmployee *empl, proc->possibleEmployees()) qDebug().noquote()<<"        possibleEmployees name="<<empl->name()<<"id="<<empl->id()<<"isExtern="<<empl->role().isExtern();

                // вывести назначенного исполнителя процедуры
                if(proc->employee()) {
                    qDebug().noquote()<<"        employee name="<<proc->employee()->name()<<"id="<<proc->employee()->id()<<"isExtern="<<proc->employee()->role().isExtern();
                }
                else qDebug()<<         "        employee name=..."; // не назначен исполнитель

                // вывести данные по работе
                foreach (TCarryWork *work,proc->works()) // цикл перебора работ
                {
                    if(work) // проверка на нулевой указатель
                    {
                        qDebug()<<"";
                        qDebug().noquote()<<"            Работа  name="<<work->name();
                        qDebug()<<          "            id="<<work->id();
                        qDebug()<<          "            num="<<work->num();

                        if(work->dtPlanBegin()) qDebug()<<"            fDtPlanBegin (begin)="<<work->dtPlanBegin()->toString("d.M.yyyy hh:mm");
                        else                    qDebug()<<"            fDtPlanBegin (begin)=...";

                        qDebug()<<"            fPlanPeriod (time)="<<work->planPeriod();

                        if(work->dtPlanBegin()) qDebug()<<"            fDtPlanEnd (end)="<<work->dtPlanEnd()->toString("d.M.yyyy hh:mm");
                        else                    qDebug()<<"            fDtPlanEnd (end)=...";

                        qDebug()<<"            !fIsVolatile (protection)="<<!work->isVolatile();
                    }
                    else
                    {
                        qDebug()<<"            id=...";
                        QMessageBox::information(0,"Ошибка", "Обнаружена пустая работа в процедуре с id=" + proc->id());
                    }
                } // конец цикла перебора работ
            } // конец цикла перебора процедур
        } // конец цикла перебора продукции (планов)
    } // конец цикла перебора проектов
}

void PrintJob() // вывести в консоль вектор job в табличном виде
{
    qDebug()<<"----------";
    qDebug()<<"Начало самого раннего года планирования из всех проектов:"<<beginyearplan;
    // вывести содержимое вектора job в консоль (для отладки). Это перечень работ по каждой продукции и каждой процедуре
    for(int i=0; i<(int)job.size(); i++){ // цикл перебора продукции-строк
        for(int j=0; j<(int)job[i].size(); j++){ // цикл перебора процедур
            for(int k=0; k<(int)job[i][j].size(); k++){ // цикл перебора работ

                QString b; // список id возможных исполнителей процедуры
                for(int l=0; l<(int)job[i][j][k].people.size(); ++l) b = b + QString::number(job[i][j][k].people[l].id) + " ";

                QString d; // список num опорных процедур
                for(int l=0; l<(int)job[i][j][k].prevprocedurenum.size(); ++l) d = d + QString::number(job[i][j][k].prevprocedurenum[l]) + " ";

                QString g; // список индексов опорных процедур
                for(int l=0; l<(int)job[i][j][k].prevprocedureind.size(); ++l) g = g + QString::number(job[i][j][k].prevprocedureind[l]) + " ";

                qDebug()<<"i:"                <<i
                        <<"j:"                <<j
                        <<"k:"                <<k
                        <<"id:"               <<job[i][j][k].id
                        <<"changes:"          <<job[i][0][0].changes // признак того, что продукция была изменена. Хранится в начальной работе продукции
                        <<"priority:"         <<job[i][j][k].priority
                        <<"proj num:"         <<job[i][j][k].projectnum
                        <<"prod num:"         <<job[i][j][k].productnum
                        <<"proc num:"         <<job[i][j][k].procedurenum
                        <<"job num:"          <<job[i][j][k].num
                        <<"protection:"       <<job[i][j][k].protection
                        <<"beginmin:"         <<job[i][j][k].beginmin
                        <<"begin:"            <<job[i][j][k].begin
                        <<"time:"             <<job[i][j][k].time
                        <<"end:"              <<job[i][j][k].end
                        <<"endmax:"           <<job[i][j][k].endmax
                        <<"executor:"         <<job[i][j][k].executor.id
                        <<"executor.external:"<<job[i][j][k].executor.external
                        <<"people.id:"        <<b  // список id возможных исполнителей
                        <<"prevproc.num:"     <<d  // список num опорных процедур
                        <<"prevproc.ind:"     <<g; // список индексов опорных процедур
            } // конец цикла перебора работ
        } // конец цикла перебора процедур
    } // конец цикла продукций
}

void PrintPlan() // вывести в консоль сформированный план
{
    // Вывести сформированный план в консоль (только для отладки)
    qDebug("\n**********  Результаты планирования **********");
    int codetekold = 0;
    QString str="";
    //int kol=250; // кол. рабочих часов, выводимых на одной строке экрана (при kol>300 будет переносе строк и потеряется наглядность на экране)
    int kol=3920; // кол. рабочих часов, выводимых на одной строке экрана (при kol>300 будет переносе строк и потеряется наглядность на экране)

    // Сформировать и вывести информацию по работе (код исполнителя, код процедуры, код продукции, время  выполнения работы)
    for(int i=0; i<(int)job.size(); ++i){ // цикл перебора продукции
        for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора работ текущей продукции
            for(int k=0; k<(int)job[i][j].size(); ++k){ // цикл перебора работ
                int codetek = job[i][j][k].executor.id; // код текущего исполнителя
                // Сформировать и вывести строку-временную ось нерабочих дней исполнителя
                str="";
                for(int h=0; h<kol; ++h) { // цикл перебора дней, начиная с 0
                    int n = job[i][j][k].executor.rest.count(h); // найти номер дня (h) в векторе rest
                    if(n) str = str + "*"; // выходной день вывести, как "*"
                    else  str = str + "="; // рабочий день вывести, как "="
                }
                // если тек. исполнитель изменился, то вывести календарь текущего исполнителя (будет меньше осей времени, больше наглядности)
                if(codetekold != codetek) qDebug()<<(str + "calendar executor.code:" + QString::number(job[i][j][k].executor.id));
                codetekold = codetek; // запомнить код текущего исполнителя
                // Сформировать и вывести информационную строку по работе
                str="";
                for(int l=0; l<job[i][j][k].begin; ++l) str = str + "-"; // сформировать строку из дефисов, количеством job[i][j].begin
                str = str
                        + "(proj:"     + QString::number(job[i][j][k].projectnum)   // num проекта
                        + " prod:"     + QString::number(job[i][j][k].productnum)   // num продукции
                        + " proc:"     + QString::number(job[i][j][k].procedurenum) // num процедуры
                        + " job:"      + QString::number(job[i][j][k].num)          // num работы
                        + " ex:"       + QString::number(job[i][j][k].executor.id)  // id исполнителя
                        + " time:"     + QString::number(job[i][j][k].time)         // время выполнения работы
                        + " priority:" + QString::number(job[i][j][k].priority)     // приоритет работы (взят из приоритета проекта)
                        + ")";
                qDebug()<<str;
            } // конец цикла перебора работ
        } // конец цикла перебора работ
    } // конец цикла перебора продукций
}

void WritePlan(TCarryTaskList &tasks) // записать результаты планирования в tasks
{
    // записать найденные результаты планирования в объект tasks:
    // begin    в поле work->fDtPlanBegin
    // end      в поле work->fDtPlanEnd
    // executor в поле work->fEmployee
    // executor в поле proc->fEmployee
    // begin    в поле fDtPlanBegin (проекта, продукции, процедуры, работы)
    // end      в поле fDtPlanEnd (проекта, продукции, процедуры, работы)

    foreach (TCarryTask *curTask,tasks) // цикл перебора проектов
    {
        // Время начала и конца текущего проекта (которые надо найти)
        int curTaskbegin = 999999;
        int curTaskend   = 0;

        for(int i=0; i<=1; i++){ // цикл перебора продукций (двух планов): План выпуска продукции (i=0) и План ОРД (i=1)
            TCarryPlan *plan; // plan - это продукция
            // Проверка. Это план выпуска продукции или ОРД?
            if(i==0) plan = curTask->carryPlan(); // план выпуска продукции
            else     plan = curTask->ordPlan();   // план ОРД

            if(!plan) continue; // пропустить пустую продукцию (план)

            if(!plan->procedures().size())continue; // пропустить продукцию, не содержащую процедуры

            // Время начала и конца текущей продукции (которые надо найти)
            int productbegin = 999999999;
            int productend   = 0;
            foreach (TCarryProcedure *proc,plan->procedures()) // цикл перебора процедур
            {
                // Время начала и конца текущей процедуры (которые надо найти)
                int procedurebegin = 999999;
                int procedureend   = 0;
                foreach (TCarryWork *work,proc->works()) // цикл перебора работ
                {
                    // зная id работы, найти из сформированного вектора job: время начала, конца и id исполнителя
                    int idtemp = work->id();                // id работы, который будем искать
                    job_type jobtemp = FindJob(idtemp);     // найти работу jobtemp в векторе job по ее id
                    int jobbegin     = jobtemp.begin;       // найденное время начала текущей работы
                    int jobend       = jobtemp.end;         // найденное время конца текущей работы
                    int executorid   = jobtemp.executor.id; // найденный исполнитель работы (он же исполнитель процедуры)

                    work->setDtPlanBegin(NumWorkHourYearToDateTime(jobbegin, begin)); // записать время начала текущей работы в формате QDateTime
                    work->setDtPlanEnd(NumWorkHourYearToDateTime(jobend, end));     // записать время конца текущей работы в формате QDateTime

                    // если есть изменения в работах продукции, то записать признак изменений в продукции. Для последующего сохранения продукции
                    if(jobtemp.changes) plan->setSaved(false); // т.е. продукция не сохранена в базе и ее надо сохранить

                    // зная id исполнителя найти его среди списка возможных исполнителей процедуры
                    foreach (TEmployee *empl, proc->possibleEmployees()) // цикл перебора возможных исполнителей процедуры
                    {
                        int tekid = empl->id(); // код текущего возможного исполнителя
                        if(executorid == tekid) { // проверка. Найден ли исполнитель?
                            work->setEmployee(empl); // записать найденного исполнителя для работы
                            proc->setEmployee(empl); // записать найденного исполнителя для процедуры
                            break;
                        }
                    } // цикл перебора возможных исполнителей процедуры
                    // Поиск времени начала и конца текущей процедуры
                    if(jobbegin < procedurebegin) procedurebegin = jobbegin;
                    if(jobend > procedureend) procedureend = jobend;
                    // Поиск времени начала и конца текущей продукции
                    if(jobbegin < productbegin) productbegin = jobbegin;
                    if(jobend > productend) productend = jobend;
                    // Поиск времени начала и конца текущего проекта
                    if(jobbegin < curTaskbegin) curTaskbegin = jobbegin;
                    if(jobend > curTaskend) curTaskend = jobend;
                } // конец цикла перебора работ

                proc->setDtPlanBegin(NumWorkHourYearToDateTime(procedurebegin, begin)); // записать время начала текущей процедуры в формате QDateTime
                proc->setDtPlanEnd(NumWorkHourYearToDateTime(procedureend, end));     // записать время конца текущей процедуры формате QDateTime
            } // конец цикла перебора процедур

            plan->setDtPlanBegin(NumWorkHourYearToDateTime(productbegin, begin)); // записать время начала текущей продукции в формате QDateTime
            plan->setDtPlanEnd(NumWorkHourYearToDateTime(productend, end));     // записать время конца текущей продукции в формате QDateTime
        } // конец плана (продукции)

        curTask->setDtPlanBegin(NumWorkHourYearToDateTime(curTaskbegin, begin)); // записать время начала текущего проекта в формате QDateTime
        curTask->setDtPlanEnd(NumWorkHourYearToDateTime(curTaskend, end));     // записать время начала текущего проекта в формате QDateTime
    } // конец цикла перебора проектов

}

bool TestJobOrderBeginEnd(int &l, int &m, int &n, int &ttek) // проверка выполнения принципа последовательности работы (прямое планирование)
{
    // Прямое планирование. Функция проверяет, может ли работа job[l][m][n] начаться во время ttek?
    //Если может, то вернуть true; если не может, то вернуть false. В рамках одной процедуры все работы выполняются строго
    //последовательно. Текущая процедура может начинаться в любое время, если нет опорных процедур. Если есть опорные процедуры, то
    //текущая процедура может начаться только после окончания всех опорных процедур

    // Проверка. Проверяемая работа начальная в процедуре?
    if(!n){ // Начальная работа процедуры. Надо анализировать опорные процедуры
        // Проверка. Есть ли опорные процедуры?
        if(job[l][m][n].prevprocedureind.empty()) return true; // если нет опорных процедур. Работа job[l][m][n] может начаться во время ttek
        else{ // если есть опорные процедуры, то найти максимальный конец из всех опорных процедур
            int endmax = 0; // максимальный конец опорных процедур
            for(int g=0; g<(int)job[l][m][n].prevprocedureind.size(); ++g){ // цикл перебора всех опорных процедур
                int ind = job[l][m][n].prevprocedureind[g]; // индекс текущей опорной процедуры
                int endtek = job[l]    [ind]   [job[l][ind].size()-1]  .end; // конец текущей опорной процедуры
                if(endtek > endmax) endmax = endtek; // запомнить новый максимальный конец опорных процедур
            }//  конец цикла перебора опорных процедур
            if(ttek <= endmax) return false; // если ttek меньше найденного значения, то ttek не подходит (вернуть false)
            else return true; // ttek подходит (вернуть true). Работа job[l][m][n] может начаться во время ttek
        }
    }
    else { // Внутренняя или последняя работа процедуры. Надо проверить на окончание предыдущей работы в рамках той же процедуры
        if(ttek <= job[l][m][n-1].end) return false; // ttek не подходит (вернуть false)
        else return true; //ttek подходит (вернуть true). Работа job[l][m][n] может начаться во время ttek
    }

}

bool TestJobOrderEndBegin(int &l, int &m, int &n, int &ttek) // проверка выполнения принципа последовательности работы (обратное планирование)
{
    // Обратное планирование. Функция проверяет, может ли работа job[l][m][n] заканчиваться во время ttek?
    //Если может, то вернуть true; если не может, то вернуть false. В рамках одной процедуры все работы выполняются строго
    //последовательно. Текущая процедура может начинаться в любое время, если нет опорных процедур. Если есть опорные процедуры, то
    //текущая процедура может начаться только после окончания всех опорных процедур

    // Проверка. Проверяемая работа job[l][m][n] последняя в процедуре?
    if(n == (job[l][m].size()-1)){ // последняя работа процедуры. Надо учитывать опирающиеся (не опорные!) процедуры
        // Если есть опирающиеся процедуры, то найти beginmin - минимальное время начала опирающихся процедур
        int beginmin = 999999999; // минимальное время начала опирающихся процедур, которое надо найти.
                                   //Время, позже которго не должна закончиться текущая работа job[l][m][n]
        // Перебрать все процедуры с индексом > m. В остальных процедурах (для индекса <= m) не м.б. проверяемой процедуры в списке опорных процедур
        for(int j=m; j<(int)job[l].size(); j++){ // цикл перебора всех процедур, начиная с индекса m
            if(j == m) continue; // пропустить саму проверяемую процедуру
            for(int g=0; g<(int)job[l][j][0].prevprocedureind.size(); ++g){ // цикл всех опорных процедур для j-ой процедуры
                int ind = job[l][j][0].prevprocedureind[g]; // индекс текущей опорной процедуры
                if(ind == m) { // Проверка. Нашли проверяемую процедуру в списке опорных?
                    int begintek = job[l]    [j]   [0]  .begin;  // запомнить начало текущей опирающейся j-ой процедуры (по началу начальной работе)
                    if(begintek < beginmin) beginmin = begintek; // запомнить новое минимальное начало опирающейся процедуры
                    break; // завершить перебор списка опорных процедур, если найдена нужная
                }
            }//  конец цикла перебора опорных процедур в j-ой процедуре
        } // конец цикла перебора всех процедур l-ой продукции
        if(beginmin == 999999999) return true; // если не нет опирающихся процедур, то ttek подходит (вернуть true)
        else { // если найдены опирающиеся процедуры, то проверить на минимальное начало опорных прпоцедур
            if(ttek >= beginmin) return false; // если ttek больше найденного значения beginmin, то ttek не подходит (вернуть false)
            else return true; // ttek подходит (вернуть true). Работа job[l][m][n] может закончиться во время ttek
        }
    }
    else { // не последняя (начальная или внутренняя) работа процедуры. Надо проверить на начало следующей (уже спланирпованной) работы той же процедуры
        if(ttek >= job[l][m][n+1].begin) return false; // ttek не подходит, пропустить его
        else return true; // ttek подходит (вернуть true). Работа job[l][m][n] может закончиться во время ttek
    }
}

int PlanJobBeginEnd(int &l, int &m, int &n, QString &errs) // прямое планирование работ
{
    // Прямое планирование. Спланировать работу job[l][m][n] (найти время начала и конца с учетом всех ограничений)
    //Исполнитель job[l][m][n].executor уже записан в работе

    int tbegin, tend; // время начала и конца работы, которые надо найти

    // Проверка. Нажата ли кн. "Прервать" в ProgressDialog ? При долгом планировании его можно прервать. Эту проверку
    //можно перенести в функцию PlanProductBeginEnd(int &i, QString &errs) для повышения быстродействия
    if(pprd->wasCanceled()){ // если нажата кн. Прервать
        numerror ++; // порядковый номер ошибки
        errs += QString("<br><b>%1</b>. Планирование прервано пользователем").arg(numerror);
        return 1; // завершить планирование аварийно
    }

    // ПРОВЕРКА. Если работа защищенная, то ничего с ней не делать (в ней ничего менять нельзя)
    if(job[l][m][n].protection) return 0; // нормальное завершение функции

    // Бесконечный цикл перебора возможных рабочих часов начала тек. работы job[l][m][n]. Из цикла выйдем тогда, когда
    //найдем самое раннее время начала тек. работы, удовлетворяющее всем ограничениям
    for(int ttek = tbeginplan;  ; ++ttek){ // бесконечный цикл перебора рабочих часов года, начиная с текущего рабочего часа

        tbegin = tend = 0; // время начала и конца работы, которые надо найти

        // ПРОВЕРКА. Если текущий рабочий час года есть в списке нерабочих часов года исполнителя job[l][m][n].executor, то пропустить его
        if(job[l][m][n].executor.rest.count(ttek)) continue; // пропустить ttek

        // ПРОВЕРКА. Если текущий рабочий час года меньше минимально разрешенного времени начала работы, то пропустить его
        //По-умолчанию beginmin = 0, т.е., если минимално возможное время начала продукции (работы) не задано, то оно = 0
        if(ttek < job[l][m][n].beginmin) continue; // пропустить ttek

        // ПРОВЕРКА. Выполняется ли принцип последовательности выполнения работ? Может ли работа job[l][m][n] начаться во время ttek?
        if(!TestJobOrderBeginEnd(l, m, n, ttek)) continue; // // пропустить ttek

        // Найти время начала (tbegin) и конца (tend) работы job[l][m][n] с учетом нерабочих часов (начиная поиск со времени ttek) для
        //исполнителя job[l][m][n].executor. Задана продолжительность работы: job[l][m][n].time
        FindBeginEndJob(job[l][m][n].executor, ttek, job[l][m][n].time, tbegin, tend); // нашли tbegin и tend

        // ПРОВЕРКА. Если исполнитель внешний,  то дублирование работ не проверять. Время начала и конца уже найдены.
        //Внешний(внутренний) исполнитель определяется, как: proc->employee()->role().isExtern()==true (внешний)
        if(job[l][m][n].executor.external) break; // внешний исполнитель. Не проверять на дублирование. Работа спланирована

        // ПРОВЕРКА предшествующих незащищенных работ. Если исполнитель внутренний, то проверить найденные tbegin и tend на
        //дублирование уже спланированных ранее незащищенных работ. Проверить незащищенные работы предшествующие индексу [l][m][n].
        bool flduplicate = false; // нет дублирования
        if(!job[l][m][n].executor.external){  // внутренний исполнитель
            for(int i=0; i<(int)job.size(); i++){ // цикл перебора продукции
                for(int j=0; j<(int)job[i].size(); j++){ // цикл перебора процедур
                    for(int k=0; k<(int)job[i][j].size(); k++){ // цикл перебора работ
                        if(job[i][j][k].executor.id != job[l][m][n].executor.id) continue; // пропустить работу с ненужным исполнителем
                        if(job[i][j][k].protection) continue; // пропустить защищенные работы, которые будут проверены в следующей проверке
                        // Проверка. Как только дойдем до тек. работы, проверку прервать
                        if((l==i) && (m==j) && (n==k)) // дошли до текущей работы, ее и последующие проверять не надо
                            goto metkastop1; // прервать все циклы, т.к. проверяем только прешествующие работы
                        // Проверка. Найдена предшествующая незащищенная работа с нужным исполнителем. Есть ли дублирование?
                        if(((tbegin >= job[i][j][k].begin) && (tbegin <= job[i][j][k].end)) || // точка tbegin проверяемого интервала попала внутрь текущего интервала
                           ((tend   >= job[i][j][k].begin) && (tend   <= job[i][j][k].end)) || // точка tend   проверяемого интервала попала внутрь текущего интервала
                           ((tbegin <= job[i][j][k].begin) && (tend   >= job[i][j][k].end))){  // проверяемый интервал полностью накрыл текущий интервал
                            flduplicate = true; // есть дублирование
                            goto metkastop1; // прервать все циклы, т.к. обнаружено дублирование
                        }
                    } // конец цикла перебора работ
                } // конец цикла перебора процедур
            } // конец цикла перебора продукции
metkastop1:; // метка досрочного выхода из цикла (,когда дошли до проверяемой работы или обнаружено дублирование)
        }
        if(flduplicate) continue; // если есть дублирование, то пропустить текущий день ttek

        // ПРОВЕРКА всех защищенных работ. Если исполнитель внутренний, то проверить найденные tbegin и tend на дублирование с защищенными
        //работами (по всем индексам работ: i, j, k). Проверить все только защищенные работы
        flduplicate = false; // нет дублирования
        if(!job[l][m][n].executor.external){  // внутренний исполнитель
            for(int i=0; i<(int)job.size(); i++){ // цикл перебора продукции
                for(int j=0; j<(int)job[i].size(); j++){ // цикл перебора процедур
                    for(int k=0; k<(int)job[i][j].size(); k++){ // цикл перебора работ
                        if(job[i][j][k].executor.id != job[l][m][n].executor.id) continue; // пропустить работу с ненужным исполнителем
                        if(!job[i][j][k].protection) continue; // пропустить незащищенную работу
                        // Проверка. Найдена защищенная работа job[i][j][k] с нужным исполнителем. Есть ли дублирование?
                        if(((tbegin >= job[i][j][k].begin) && (tbegin <= job[i][j][k].end)) || // точка tbegin проверяемого интервала попала внутрь текущего интервала
                           ((tend   >= job[i][j][k].begin) && (tend   <= job[i][j][k].end)) || // точка tend   проверяемого интервала попала внутрь текущего интервала
                           ((tbegin <= job[i][j][k].begin) && (tend   >= job[i][j][k].end))){  // проверяемый интервал полностью накрыл текущий интервал
                            flduplicate = true;  // есть дублирование
                            goto metkastop2; // прервать все циклы, т.к. обнаружено дублирование
                        }
                    } // конец цикла перебора работ
                } // конец цикла перебора процедур
            } // конец цикла перебора продукции
metkastop2:; // метка выхода из цикла
        }
        if(flduplicate) continue; // если есть дублирование, то пропустить текущий день ttek

        // Если дошли до конца цикла перебора ttek, значит все проверки пройдены. Даты начала и конца найдены.
        break; // выйти из цикла перебора рабочих часов, планирование работы job[l][m][n] - успешно завершено
    } // конец цикла перебора рабочих часов года

    // Из цикла вышли только тогда, когда работа спланирована, т.е. найдены tbegin и tend с учетом всех ограничений
    job[l][m][n].begin = tbegin; // записать найденное время начала
    job[l][m][n].end   = tend;   // записать найденное время конца

    return 0;
}

int PlanJobEndBegin(int &l, int &m, int &n, QString &errs) // обратное планирование работ
{
    // Обратное планирование. Спланировать работу job[l][m][n] (найти время конца и затем время начала с учетом всех ограничений)
    //Пробный исполнитель job[l][m][n].executor уже записан в работе.
    //Планировать с конца, т.е. вначале найти конец работы, и только потом найти начало работы с учетом ограничений

    int tbegin, tend; // время начала и конца работы, которые надо найти

    // Проверка. Нажата ли кн. в ProgressDialog Прервать? При долгом планировании его можно прервать. Эту проверку
    //можно перенести в функцию PlanProductBeginEnd(int &i, QString &errs) для повышения быстродействия
    if(pprd->wasCanceled()){ // если нажата кн. Прервать
        numerror ++; // порядковый номер ошибки
        errs += QString("<br><b>%1</b>. Планирование прервано пользователем").arg(numerror);
        return 1; // завершить планирование аварийно
    }

    // ПРОВЕРКА. Если работа защищенная, то ничего с ней не делать (в ней ничего менять нельзя)
    if(job[l][m][n].protection) return 0; // нормальное завершение функции

    // Бесконечный цикл перебора возможных рабочих часов КОНЦА тек. работы job[l][m][n] (справа налево). Из цикла выйдем тогда, когда
    //найдем самое позднее время НАЧАЛА тек. работы, удовлетворяющее всем ограничениям. Будем стремиться к тому, что бы
    //продукцию выполнить за наименьшее время к заданному сроку. Т.е. сместить все работы вправо по максимуму

    int endmax = job[l][m][n].endmax; // максимально заданное время конца продукции. Здесь оно никогда не равно 0

    for(int ttek = endmax;  ; --ttek){ // бесконечный цикл перебора рабочих часов года (справа налево), начиная с максимально заданного времени конца продукции
        tbegin = tend = 0; // время начала и конца работы, которые надо найти

        // ПРОВЕРКА. Если текущий рабочий час года есть в списке нерабочих часов года исполнителя job[l][m][n].executor, то пропустить его
        if(job[l][m][n].executor.rest.count(ttek)) continue; // пропустить ttek

        // ПРОВЕРКА. Если текущий рабочий час года больше максимально разрешенного времени конца работы, то пропустить его
        if(ttek >= job[l][m][n].endmax) continue; // пропустить ttek


        // ПРОВЕРКА. Выполняется ли принцип последовательности выполнения работ? Может ли работа job[l][m][n] заканчиваться во время ttek?
        if(!TestJobOrderEndBegin(l, m, n, ttek)) continue; // // пропустить ttek

        // Найти время начала (tbegin) и конца (tend) работы job[l][m][n] с учетом нерабочих часов (начиная поиск со времени ttek) для
        //исполнителя job[l][m][n].executor. Задана продолжительность работы: job[l][m][n].time. Планирование обратное, т.е. справа налево
        FindEndBeginJob(job[l][m][n].executor, ttek, job[l][m][n].time, tbegin, tend); // нашли tbegin и tend

        // ПРОВЕРКА. Если исполнитель внешний,  то дублирование работ не проверять. Время начала и конца уже найдены.
        //Внешний(внутренний) исполнитель определяется, как: proc->employee()->role().isExtern()==true (внешний)
        if(job[l][m][n].executor.external) break; // внешний исполнитель. Не проверять на дублирование. Работа спланирована
        //если исполнитель внутренний, то проверки - продолжаем

        // ПРОВЕРКА предшествующих незащищенных работ. Если исполнитель внутренний, то проверить найденные tbegin и tend на
        //дублирование уже спланированных ранее незащищенных работ. Проверить незащищенные работы предшествующие индексу [l][m][n].
        bool flduplicate = false; // нет дублирования
        if(!job[l][m][n].executor.external){  // внутренний исполнитель
            for(int i=0; i<(int)job.size(); i++){ // цикл перебора продукции (слева направо)
                for(int j=job[i].size()-1; j>=0; j--){ // цикл перебора процедур (справо налево)
                    for(int k=job[i][j].size()-1; k>=0; k--){ // цикл перебора работ (справо налево)
                        if(job[i][j][k].executor.id != job[l][m][n].executor.id) continue; // пропустить работу с ненужным исполнителем
                        if(job[i][j][k].protection) continue; // пропустить защищенные работы, которые будут проверены в следующей проверке
                        // Проверка. Как только дойдем до тек. работы, проверку прервать
                        if((l==i) && (m==j) && (n==k)) // дошли до текущей работы, ее и последующие проверять не надо
                            goto metkastop1; // прервать все циклы, т.к. проверяем только прешествующие работы
                        // Проверка. Найдена предшествующая незащищенная работа с нужным исполнителем. Есть ли дублирование?
                        if(((tbegin >= job[i][j][k].begin) && (tbegin <= job[i][j][k].end)) || // точка tbegin проверяемого интервала попала внутрь текущего интервала
                           ((tend   >= job[i][j][k].begin) && (tend   <= job[i][j][k].end)) || // точка tend   проверяемого интервала попала внутрь текущего интервала
                           ((tbegin <= job[i][j][k].begin) && (tend   >= job[i][j][k].end))){  // проверяемый интервал полностью накрыл текущий интервал
                            flduplicate = true; // есть дублирование
                            goto metkastop1; // прервать все циклы, т.к. обнаружено дублирование
                        }
                    } // конец цикла перебора работ
                } // конец цикла перебора процедур
            } // конец цикла перебора продукции
metkastop1:; // метка досрочного выхода из цикла (,когда дошли до проверяемой работы или обнаружено дублирование
        }
        if(flduplicate) continue; // если есть дублирование, то пропустить текущий день ttek

        // ПРОВЕРКА всех защищенных работ. Если исполнитель внутренний, то проверить найденные tbegin и tend на дублирование с защищенными
        //работами (по всем индексам работ: i, j, k). Проверить все только защищенные работы
        flduplicate = false; // нет дублирования
        if(!job[l][m][n].executor.external){  // внутренний исполнитель
            for(int i=0; i<(int)job.size(); i++){ // цикл перебора продукции (слева направо)
                for(int j=job[i].size()-1; j>=0; j--){ // цикл перебора процедур (справо налево)
                    for(int k=job[i][j].size()-1; k>=0; k--){ // цикл перебора работ (справо налево)
                        if(job[i][j][k].executor.id != job[l][m][n].executor.id) continue; // пропустить работу с ненужным исполнителем
                        if(!job[i][j][k].protection) continue; // пропустить незащищенную работу
                        // Проверка. Найдена защищенная работа job[i][j][k] с нужным исполнителем. Есть ли дублирование?
                        if(((tbegin >= job[i][j][k].begin) && (tbegin <= job[i][j][k].end)) || // точка tbegin проверяемого интервала попала внутрь текущего интервала
                           ((tend   >= job[i][j][k].begin) && (tend   <= job[i][j][k].end)) || // точка tend   проверяемого интервала попала внутрь текущего интервала
                           ((tbegin <= job[i][j][k].begin) && (tend   >= job[i][j][k].end))){  // проверяемый интервал полностью накрыл текущий интервал
                            flduplicate = true;  // есть дублирование
                            goto metkastop2; // прервать все циклы, т.к. обнаружено дублирование
                        }
                    } // конец цикла перебора работ
                } // конец цикла перебора процедур
            } // конец цикла перебора продукции
metkastop2:; // метка выхода из цикла
        }
        if(flduplicate) continue; // если есть дублирование, то пропустить текущий день ttek

        // Если дошли до конца цикла перебора ttek, значит все проверки пройдены. Даты начала и конца найдены.
        break; // выйти из цикла перебора рабочих часов, планирование работы job[l][m][n] - успешно завершено
    } // конец цикла перебора рабочих часов года

    // Из цикла вышли только тогда, когда работа спланирована, т.е. найдены tbegin и tend с учетом всех ограничений
    job[l][m][n].begin = tbegin; // записать найденное время начала
    job[l][m][n].end   = tend;   // записать найденное время конца

    return 0;
}

int PlanProductBeginEnd(int &i, QString &errs){ // прямое планирование продукции
    // Спланировать i-ую продукцию, у которой НЕ задано максимально разрешенное время конца.
    //При этом минимальное разрешенное время начала м.б. задано или не задано


    for(int j=0; j<(int)job[i].size(); ++j){ // цикл перебора процедур i-ой продукции

        // работа с ProgressDialog
        pprd->setValue(++step); // обновить состояние индикатора прогресса
        qApp->processEvents();  // показать ProgressDialog

        // Каждая процедура м.б. выполнена несколькими исполнителями. Проверить каждого. Кто быстрее выполнит, того и выбрать
        int endmin = 999999999; // минимальное время конца процедуры
        executor_type executormin = job[i][j][0].people[0]; // пока лучший исполнитель (из начальной работы процедуры) ТАК БЫЛО
        for(int indexecutor = 0; indexecutor<(int)job[i][j][0].people.size(); indexecutor++){ // цикл перебора возможных исполнителей тек. процедуры

            // назначить текущего исполнителя: job[i][j][k].people[indexecutor] всем работам текущей процедуры
            for(int k=0; k<(int)job[i][j].size(); k++){ // цикл перебора работ j-ой процедуры
                if(job[i][j][k].protection) continue; // пропустить защищенную работу, в ней менять исполнителя нельзя
                job[i][j][k].executor = job[i][j][k].people[indexecutor];
            } // конец цикла перебора работ j-ой процедуры

            // спланировать все работы текущей процедуры: job[i][j] текущим исполнителем: job[i][j][k].people[indexecutor]
            for(int k=0; k<(int)job[i][j].size(); k++){
                if(PlanJobBeginEnd(i, j, k, errs) !=0) return 1; // планирование работ процедуры
            }

            // Определить время окончания текущей процедуры, как время конца последней работы в текущей процедуре
            int klast = job[i][j].size()-1; // индекс k последней работы в текущей процедуре
            int end = job[i][j][klast].end; // время конца последней работы текущей процедуры (т.е. время конца тек. процедуры)
            // Проверка. Если это лучшее время выполнения всей тек. процедуры, то запомнить это время и этого исполнителя
            if(end < endmin){
                endmin      = job[i][j][klast].end;
                executormin = job[i][j][klast].executor;
            }
        } // конец цикла перебора возможных исполнителей процедуры. Найден лучший исполнитель executormin

        // назначить найденного лучшего исполнителя: executormin всем работам текущей процедуры
        for(int k=0; k<(int)job[i][j].size(); k++){
            if(job[i][j][k].protection) continue; // пропустить защищенную работу, в ней менять исполнителя нельзя
            job[i][j][k].executor = executormin;
        }

        // Окончательно (еще раз) спланировать все работы текущей процедуры: job[i][j] теперь уже с найденным лучшим исполнителем
        for(int k=0; k<(int)job[i][j].size(); k++){
            if(PlanJobBeginEnd(i, j, k, errs) != 0) return 1; // планирование работ процедуры
        }

    } // конец цикла перебора процедур

    return 0;
}

int PlanProductEndBegin(int &i, QString &errs){ // обратное планирование продукции
    // Спланировать i-ую продукцию, у которой задано максимально разрешенное время конца продукции
    //При этом минимальное разрешенное время начала м.б. задано или не задано

    for(int j=job[i].size()-1; j>=0; j--){ // обратный цикл перебора процедур i-ой продукции

        //qDebug()<<"j="<<j; // здесь все верно

        // работа с ProgressDialog
        pprd->setValue(++step); // обновить состояние индикатора прогресса
        qApp->processEvents();  // показать ProgressDialog

        // Каждая процедура м.б. выполнена несколькими исполнителями. Проверить каждого. Кто позже начнет выполнять процедуру и
        //завершит выполнение процедуры к заданному сроку, того и выбрать. Т.е., кто выполнить работу за минимальное время к заданному сроку
        int beginmax = 0; // максимальное время начала процедуры. Т.е. максимальное время, когда можно начать продукцию и завершить ее к заданному времени
        executor_type executormax = job[i][j][0].people[0]; // пока лучший исполнитель (из начальной работы процедуры), который начнет выполнение процедуры
        //в максимальное время и выполнит ее к заданному сроку
        for(int indexecutor = 0; indexecutor<(int)job[i][j][0].people.size(); indexecutor++){ // цикл перебора возможных исполнителей тек. процедуры

            // назначить текущего исполнителя: job[i][j][k].people[indexecutor] всем работам текущей процедуры
            for(int k=job[i][j].size()-1; k>=0; k--){
                if(job[i][j][k].protection) continue; // пропустить защищенную работу, в ней менять исполнителя нельзя
                job[i][j][k].executor = job[i][j][k].people[indexecutor];
            }

            // спланировать все работы текущей процедуры: job[i][j] текущим исполнителем: job[i][j][k].people[indexecutor]
            for(int k=job[i][j].size()-1; k>=0; k--){ // цикл обратного перебора работ

                //qDebug()<<"i="<<i<<"j="<<j<<"k="<<k; // здесь все верно

                if(PlanJobEndBegin(i, j, k, errs) !=0) return 1; // обратное планирование работ процедуры
            } // конец цикла обратного перебора работ
            // Определить время начала текущей процедуры, как время начала 0-ой работы в текущей процедуре
            int begin = job[i][j][0].begin; // время начала 0-ой работы текущей процедуры (т.е. время начала тек. процедуры)
            // Проверка. Если это лучшее (самое позднее!) время начала выполнения тек. процедуры, то запомнить это время и этого исполнителя
            if(begin > beginmax){
                beginmax      = job[i][j][0].begin; // запомнить начало процедуры
                executormax = job[i][j][0].executor;
            }
        } // конец цикла перебора возможных исполнителей процедуры. Найден лучший исполнитель executormin

        // назначить найденного лучшего исполнителя: executormax всем работам текущей процедуры
        //for(int k=job[i][j].size()-1; k>=0; k--) job[i][j][k].executor = executormax;
        for(int k=job[i][j].size()-1; k>=0; k--){
            if(job[i][j][k].protection) continue; // пропустить защищенную работу, в ней менять исполнителя нельзя
            job[i][j][k].executor = executormax;
        }

        // Окончательно (еще раз) спланировать все работы текущей процедуры: job[i][j] теперь уже с лучшим исполнителем
        for(int k=job[i][j].size()-1; k>=0; k--){
            if(PlanJobEndBegin(i, j, k, errs) != 0) return 1; // планирование работ процедуры
        }

    } // конец обратного цикла перебора процедур i-ой продукции
    return 0;
}

int Plan(TCarryTaskList &tasks, QString &errs) // основная процедура
{

    // Найти tbeginplan - время начала планирования. Это начальный час, с которого будем планировать. Это текущий рабочий час года (аналог текущей даты)
    QDateTime currentDateTime(QDate::currentDate(), QTime::currentTime()); // текущие: дата и время
    tbeginplan = DateTimeToNumWorkHourYear(currentDateTime, begin);        // текущий рабочий час года (от 0 до 365*8)

    if(TestTCarryTaskBeforePlanning(tasks, errs)) return 5; // проверить содержимое объекта tasks до начала планирования
    if(flprint>=3) PrinTCarryTask(tasks);                   // для отладки вывести в консоль содержимое объекта tasks до начала планирования
    FillVectorJob(tasks);                                   // заполнить вектор job данными из объекта tasks

    FillVectorJobIndPrevProcedure();                        // в векторе job зная id предшествующих процедур заполнить индексы опорных процедур

    CorrectionProcedure();                                  // проверка возможных исполнителей процедур
    SortingVectorJob();                                     // отсортировать вектор job в соответствии с приоритетами проектов
    if(flprint>=2) PrintJob();                              // для отладки вывести в консоль данные вектора job в табличной форме до начала планирования
    if(TestJobBeforePlanning(errs)) return 1;               // проверить данные в векторе job до начала планирования

    // Планирование продукций
    for(int i=0; i<(int)job.size(); i++){ // цикл перебора продукций
        // Проверка. Какое требуется планирование продукции: прямое или обратное?
        if(job[i][0][0].endmax){ // если задано максимально разрешенное время конца продукции
            if(PlanProductEndBegin(i, errs)) return 1;   // обратное планирование i-ой продукции
        }
        else { // если НЕ задано максимально разрешенное время конца продукции
            if(PlanProductBeginEnd(i, errs)) return 1;  // прямое планирование i-ой продукции
        }
    } // конец цикла перебора продукций

    if(flprint>=2) PrintJob();                             // для отладки вывести данные вектора job после планирования
    if(TestPlan(errs)) return 1;                           // проверить сформированный план на грубые ошибки
    if(flprint>=1) PrintPlan();                            // для отладки вывести в консоль сформированный план
    WritePlan(tasks);                                      // записать найденные результаты планирования в объект tasks
    if(TestTCarryTaskAfterPlanning(tasks, errs)) return 7; // проверить содержимое объекта tasks после записи в него результатов планирования
    if(flprint>=3) PrinTCarryTask(tasks);                  // для отладки вывести содержимое объекта tasks после записи в него результатов планирования

    return 0; // успешное завершение планирования
}

// Основная функция планирования
// tasks - список проектов      - ВХОД и ВЫХОД
// ers  - сообщение об ошибках - ВЫХОД
// ВОЗВРАТ - признак успешности
bool TModulePlans::createCarryPlans(TCarryTaskList &tasks, QString &errs)
{
    numerror = 0; // порядковый номер ошибки для возвращаемого сообщения об ошибке

    // индикатор прогресса ProgressDialog
    step = 0;     // счетчик процедур
    kolproc = 0;  // общее количество процедур в векторе job (максимальное значение индикатора)
    pprd = new QProgressDialog("Выполнение...", "&Cancel", 0, 0); // создать новый ProgressDialog
    //pprd->setMinimumDuration(3000);        // задержка показа окна на 3 сек (3000 млсек). Процесс менее 3 сек - не показывать
    pprd->setWindowTitle("Планирование");  // заголовок окна
    pprd->setCancelButtonText("Прервать"); // надпись на кн. Cancel

    errs = "";
    if (!tasks.count()){
        errs += QString("<br>Ошибка. Список проектов пуст");
        return false;
    }

    int kodvozvrata = Plan(tasks, errs); // выполнить собственно планирование. Вернуть: 0-без ошибок, 1-есть ошибки.

    delete pprd; // закрыть окно и удалить ProgressDialog после планирования

    // Проверка. Были ошибки при планировании?
    if(kodvozvrata) return false; // вернуть false, если были ошибки
    else return true;             // вернуть true, если нет ошибок
}
